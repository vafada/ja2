namespace ja2 {

// DEFINES FOR VARIOUS PANELS
const CLOCK_X = 554;
const CLOCK_Y = 459;
const SM_ITEMDESC_START_X = 214;
const SM_ITEMDESC_START_Y = 1 + INV_INTERFACE_START_Y;
const SM_ITEMDESC_HEIGHT = 128;
const SM_ITEMDESC_WIDTH = 358;

// SINGLE MERC SCREEN

const SM_SELMERC_AP_X = 70;
const SM_SELMERC_AP_Y = 393;
const SM_SELMERC_AP_HEIGHT = 12;
const SM_SELMERC_AP_WIDTH = 11;

const SM_SELMERC_BREATH_X = 75;
const SM_SELMERC_BREATH_Y = 387;
const SM_SELMERC_BREATH_WIDTH = 3;
const SM_SELMERC_BREATH_HEIGHT = 42;

const SM_SELMERC_HEALTH_X = 69;
const SM_SELMERC_HEALTH_Y = 387;
const SM_SELMERC_HEALTH_WIDTH = 3;
const SM_SELMERC_HEALTH_HEIGHT = 42;

const SM_SELMERC_MORALE_X = 81;
const SM_SELMERC_MORALE_Y = 387;
const SM_SELMERC_MORALE_WIDTH = 3;
const SM_SELMERC_MORALE_HEIGHT = 42;

const SM_SELMERCNAME_X = 7;
const SM_SELMERCNAME_Y = 395;

const SM_SELMERCNAME_WIDTH = 53;
const SM_SELMERCNAME_HEIGHT = 9;

const SM_SELMERC_FACE_X = 13;
const SM_SELMERC_FACE_Y = 346;
const SM_SELMERC_FACE_HEIGHT = 42;
const SM_SELMERC_FACE_WIDTH = 48;

const SM_SELMERC_PLATE_X = 4;
const SM_SELMERC_PLATE_Y = 342;
const SM_SELMERC_PLATE_HEIGHT = 65;
const SM_SELMERC_PLATE_WIDTH = 83;

const SM_BODYINV_X = 244;
const SM_BODYINV_Y = 346;

const STATS_TITLE_FONT_COLOR = 6;
const STATS_TEXT_FONT_COLOR = 5;

const SM_TALKB_X = 155;
const SM_TALKB_Y = 448;
const SM_MUTEB_X = 91;
const SM_MUTEB_Y = 448;
const SM_STANCEUPB_X = 187;
const SM_STANCEUPB_Y = 380;
const SM_UPDOWNB_X = 91;
const SM_UPDOWNB_Y = 413;
const SM_CLIMBB_X = 187;
const SM_CLIMBB_Y = 348;
const SM_STANCEDOWNB_X = 187;
const SM_STANCEDOWNB_Y = 448;
const SM_HANDCURSORB_X = 123;
const SM_HANDCURSORB_Y = 413;
const SM_PREVMERCB_X = 9;
const SM_PREVMERCB_Y = 410;
const SM_NEXTMERCB_X = 51;
const SM_NEXTMERCB_Y = 410;
const SM_OPTIONSB_X = 9;
const SM_OPTIONSB_Y = 445;
const SM_BURSTMODEB_X = 155;
const SM_BURSTMODEB_Y = 413;
const SM_LOOKB_X = 123;
const SM_LOOKB_Y = 448;
const SM_STEALTHMODE_X = 187;
const SM_STEALTHMODE_Y = 413;
const SM_DONE_X = 543;
const SM_DONE_Y = 344;
const SM_MAPSCREEN_X = 589;
const SM_MAPSCREEN_Y = 344;

const SM_POSITIONB_X = 106 + INTERFACE_START_X;
const SM_POSITIONB_Y = 34 + INV_INTERFACE_START_Y;
const SM_POSITIONB_WIDTH = 19;
const SM_POSITIONB_HEIGHT = 24;

const SM_PERCENT_WIDTH = 20;
const SM_PERCENT_HEIGHT = 10;
const SM_ARMOR_X = 347;
const SM_ARMOR_Y = 419;
const SM_ARMOR_LABEL_X = 363;
const SM_ARMOR_LABEL_Y = 409;
const SM_ARMOR_PERCENT_X = 368;
const SM_ARMOR_PERCENT_Y = 419;

const SM_WEIGHT_LABEL_X = 430;
const SM_WEIGHT_LABEL_Y = 447;
const SM_WEIGHT_PERCENT_X = 449;
const SM_WEIGHT_PERCENT_Y = 446;
const SM_WEIGHT_X = 428;
const SM_WEIGHT_Y = 446;

const SM_CAMMO_LABEL_X = 430;
const SM_CAMMO_LABEL_Y = 462;
const SM_CAMMO_PERCENT_X = 449;
const SM_CAMMO_PERCENT_Y = 461;
const SM_CAMMO_X = 428;
const SM_CAMMO_Y = 461;

const SM_STATS_WIDTH = 30;
const SM_STATS_HEIGHT = 8;
const SM_AGI_X = 99;
const SM_AGI_Y = 347;
const SM_DEX_X = 99;
const SM_DEX_Y = 357;
const SM_STR_X = 99;
const SM_STR_Y = 367;
const SM_CHAR_X = 99;
const SM_CHAR_Y = 377;
const SM_WIS_X = 99;
const SM_WIS_Y = 387;
const SM_EXPLVL_X = 148;
const SM_EXPLVL_Y = 347;
const SM_MRKM_X = 148;
const SM_MRKM_Y = 357;
const SM_EXPL_X = 148;
const SM_EXPL_Y = 367;
const SM_MECH_X = 148;
const SM_MECH_Y = 377;
const SM_MED_X = 148;
const SM_MED_Y = 387;

const MONEY_X = 460;
const MONEY_Y = 445;
const MONEY_WIDTH = 30;
const MONEY_HEIGHT = 22;

const TM_FACE_WIDTH = 48;
const TM_FACE_HEIGHT = 43;

const TM_APPANEL_HEIGHT = 56;
const TM_APPANEL_WIDTH = 16;

const TM_ENDTURN_X = 507;
const TM_ENDTURN_Y = (9 + INTERFACE_START_Y);
const TM_ROSTERMODE_X = 507;
const TM_ROSTERMODE_Y = (45 + INTERFACE_START_Y);
const TM_DISK_X = 507;
const TM_DISK_Y = (81 + INTERFACE_START_Y);

const TM_NAME_WIDTH = 60;
const TM_NAME_HEIGHT = 9;
const TM_LIFEBAR_WIDTH = 3;
const TM_LIFEBAR_HEIGHT = 42;
const TM_FACEHIGHTL_WIDTH = 84;
const TM_FACEHIGHTL_HEIGHT = 114;
const TM_AP_HEIGHT = 10;
const TM_AP_WIDTH = 15;

const TM_INV_WIDTH = 58;
const TM_INV_HEIGHT = 23;
const TM_INV_HAND1STARTX = 8;
const TM_INV_HAND1STARTY = (67 + INTERFACE_START_Y);
const TM_INV_HAND2STARTX = 8;
const TM_INV_HAND2STARTY = (93 + INTERFACE_START_Y);
const TM_INV_HAND_SEP = 83;
const TM_INV_HAND_SEPY = 24;

const TM_BARS_REGION_HEIGHT = 47;
const TM_BARS_REGION_WIDTH = 26;

const INDICATOR_BOX_WIDTH = 12;
const INDICATOR_BOX_HEIGHT = 10;

const enum Enum218 {
  STANCEUP_IMAGES = 0,
  UPDOWN_IMAGES,
  CLIMB_IMAGES,
  STANCEDOWN_IMAGES,
  HANDCURSOR_IMAGES,
  PREVMERC_IMAGES,
  NEXTMERC_IMAGES,
  OPTIONS_IMAGES,
  // BURSTMODE_IMAGES,
  LOOK_IMAGES,
  TALK_IMAGES,
  MUTE_IMAGES,
  STANCE_IMAGES,
  DONE_IMAGES,
  MAPSCREEN_IMAGES,
  NUM_SM_BUTTON_IMAGES,
}

const enum Enum219 {
  ENDTURN_IMAGES = 0,
  ROSTERMODE_IMAGES,
  DISK_IMAGES,
  NUM_TEAM_BUTTON_IMAGES,
}

let iSMPanelImages: INT32[] /* [NUM_SM_BUTTON_IMAGES] */ = createArray(Enum218.NUM_SM_BUTTON_IMAGES, 0);
let iBurstButtonImages: INT32[] /* [NUM_WEAPON_MODES] */ = createArray(Enum265.NUM_WEAPON_MODES, 0);
let iTEAMPanelImages: INT32[] /* [NUM_TEAM_BUTTON_IMAGES] */ = createArray(Enum219.NUM_TEAM_BUTTON_IMAGES, 0);

let giSMStealthImages: INT32 = -1;
export let giSMStealthButton: INT32 = -1;

export let gfSwitchPanel: boolean = false;
export let gbNewPanel: UINT8 = Enum215.SM_PANEL;
export let gubNewPanelParam: UINT8 = 0;

export let gfUIStanceDifferent: boolean = false;
let gfAllDisabled: boolean = false;

export let gfSMDisableForItems: boolean = false;

export let gfDisableTacticalPanelButtons: boolean = false;

export let gfAddingMoneyToMercFromPlayersAccount: boolean = false;

export let gfCheckForMouseOverItem: boolean = false;
export let guiMouseOverItemTime: UINT32 = 0;
export let gbCheckForMouseOverItemPos: INT8 = 0;
export let gubSelectSMPanelToMerc: UINT8 = NOBODY;
let gfReEvaluateDisabledINVPanelButtons: boolean = false;

export let guiBrownBackgroundForTeamPanel: UINT32;
let guiGoldBackgroundForTeamPanel: UINT32;

let gubHandPos: UINT8;
let gusOldItemIndex: UINT16;
let gusNewItemIndex: UINT16;
let gfDeductPoints: boolean;

// ARRAY FOR INV PANEL INTERFACE ITEM POSITIONS
let gSMInvPocketXY: INV_REGION_DESC[] /* [] */ = [
  createInvRegionDescFrom(344, 347), // HELMETPOS
  createInvRegionDescFrom(344, 376), // VESTPOS
  createInvRegionDescFrom(344, 436), // LEGPOS,
  createInvRegionDescFrom(226, 347), // HEAD1POS
  createInvRegionDescFrom(226, 371), // HEAD2POS
  createInvRegionDescFrom(226, 424), // HANDPOS,
  createInvRegionDescFrom(226, 448), // SECONDHANDPOS
  createInvRegionDescFrom(468, 346), // BIGPOCK1
  createInvRegionDescFrom(468, 370), // BIGPOCK2
  createInvRegionDescFrom(468, 394), // BIGPOCK3
  createInvRegionDescFrom(468, 418), // BIGPOCK4
  createInvRegionDescFrom(396, 346), // SMALLPOCK1
  createInvRegionDescFrom(396, 370), // SMALLPOCK2
  createInvRegionDescFrom(396, 394), // SMALLPOCK3
  createInvRegionDescFrom(396, 418), // SMALLPOCK4
  createInvRegionDescFrom(432, 346), // SMALLPOCK5
  createInvRegionDescFrom(432, 370), // SMALLPOCK6
  createInvRegionDescFrom(432, 394), // SMALLPOCK7
  createInvRegionDescFrom(432, 418), // SMALLPOCK8
];

// X, Y Location of cammo region
let gSMCamoXY: INV_REGION_DESC = createInvRegionDescFrom(SM_BODYINV_X, SM_BODYINV_Y);

let sTEAMAPPanelXY: INT16[] /* [] */ = [
  69, (6 + INTERFACE_START_Y),
  151, (6 + INTERFACE_START_Y),
  234, (6 + INTERFACE_START_Y),
  317, (6 + INTERFACE_START_Y),
  401, (6 + INTERFACE_START_Y),
  484, (6 + INTERFACE_START_Y),
];

let sTEAMFacesXY: INT16[] /* [] */ = [
  13, (366),
  97, (366),
  180, (366),
  263, (366),
  346, (366),
  429, (366),
];

let sTEAMNamesXY: INT16[] /* [] */ = [
  7, (415),
  90, (415),
  173, (415),
  256, (415),
  339, (415),
  422, (415),
];

let sTEAMFaceHighlXY: INT16[] /* [] */ = [
  4, (2 + INTERFACE_START_Y),
  87, (2 + INTERFACE_START_Y),
  170, (2 + INTERFACE_START_Y),
  253, (2 + INTERFACE_START_Y),
  336, (2 + INTERFACE_START_Y),
  419, (2 + INTERFACE_START_Y),
];

let sTEAMLifeXY: INT16[] /* [] */ = [
  69, (365 + TM_LIFEBAR_HEIGHT),
  152, (365 + TM_LIFEBAR_HEIGHT),
  235, (365 + TM_LIFEBAR_HEIGHT),
  318, (365 + TM_LIFEBAR_HEIGHT),
  401, (365 + TM_LIFEBAR_HEIGHT),
  484, (365 + TM_LIFEBAR_HEIGHT),
];

let sTEAMBreathXY: INT16[] /* [] */ = [
  75, (365 + TM_LIFEBAR_HEIGHT),
  158, (365 + TM_LIFEBAR_HEIGHT),
  241, (365 + TM_LIFEBAR_HEIGHT),
  324, (365 + TM_LIFEBAR_HEIGHT),
  407, (365 + TM_LIFEBAR_HEIGHT),
  490, (365 + TM_LIFEBAR_HEIGHT),
];

let sTEAMMoraleXY: INT16[] /* [] */ = [
  81, (365 + TM_LIFEBAR_HEIGHT),
  164, (365 + TM_LIFEBAR_HEIGHT),
  247, (365 + TM_LIFEBAR_HEIGHT),
  330, (365 + TM_LIFEBAR_HEIGHT),
  413, (365 + TM_LIFEBAR_HEIGHT),
  496, (365 + TM_LIFEBAR_HEIGHT),
];

let sTEAMApXY: INT16[] /* [] */ = [
  70, (413),
  153, (413),
  235, (413),
  319, (413),
  402, (413),
  485, (413),
];

let sTEAMBarsXY: INT16[] /* [] */ = [
  61, (363),
  145, (363),
  228, (363),
  311, (363),
  394, (363),
  477, (362),
];

let sTEAMHandInvXY: INT16[] /* [] */ = [
  TM_INV_HAND1STARTX + (0 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (1 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (2 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (3 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (4 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (5 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
];

export let iSMPanelButtons: INT32[] /* [NUM_SM_BUTTONS] */ = createArray(Enum220.NUM_SM_BUTTONS, 0);
export let iTEAMPanelButtons: INT32[] /* [NUM_TEAM_BUTTONS] */ = createArray(Enum221.NUM_TEAM_BUTTONS, 0);

// Video Surface for Single Merc Panel
let guiSMPanel: UINT32;
let guiSMObjects: UINT32;
let guiSMObjects2: UINT32;
export let guiSecItemHiddenVO: UINT32;

let guiTEAMPanel: UINT32;
let guiTEAMObjects: UINT32;

// Globals for various mouse regions
let gSM_SELMERCPanelRegion: MOUSE_REGION = createMouseRegion();
let gSM_SELMERCBarsRegion: MOUSE_REGION = createMouseRegion();
export let gSM_SELMERCMoneyRegion: MOUSE_REGION = createMouseRegion();
let gSM_SELMERCEnemyIndicatorRegion: MOUSE_REGION = createMouseRegion();
let gTEAM_PanelRegion: MOUSE_REGION = createMouseRegion();
let gTEAM_FaceRegions: MOUSE_REGION[] /* [6] */ = createArrayFrom(6, createMouseRegion);
let gTEAM_BarsRegions: MOUSE_REGION[] /* [6] */ = createArrayFrom(6, createMouseRegion);
let gTEAM_LeftBarsRegions: MOUSE_REGION[] /* [6] */ = createArrayFrom(6, createMouseRegion);
let gTEAM_FirstHandInv: MOUSE_REGION[] /* [6] */ = createArrayFrom(6, createMouseRegion);
let gTEAM_SecondHandInv: MOUSE_REGION[] /* [6] */ = createArrayFrom(6, createMouseRegion);
let gTEAM_EnemyIndicator: MOUSE_REGION[] /* [6] */ = createArrayFrom(6, createMouseRegion);

let gfTEAM_HandInvDispText: UINT8[][] /* boolean[6][NUM_INV_SLOTS] */ = createArrayFrom(6, () => createArray(Enum261.NUM_INV_SLOTS, 0));
let gfSM_HandInvDispText: boolean[] /* [NUM_INV_SLOTS] */ = createArray(Enum261.NUM_INV_SLOTS, false);

// Globals - for one - the current merc here
export let gusSMCurrentMerc: UINT16 = 0;
export let gpSMCurrentMerc: SOLDIERTYPE /* Pointer<SOLDIERTYPE> */ = <SOLDIERTYPE><unknown>null;
let gbSMCurStanceObj: INT8;

let gbStanceButPos: INT8[][][] /* [2][3][3] */ = [
  // NON-STEALTH
  [
    [ 16, 14, 15 ],
    [ 10, 8, 9 ],
    [ 22, 20, 21 ],
  ],

  // STEALTH MODE
  [
    [ 13, 11, 12 ],
    [ 7, 5, 6 ],
    [ 19, 17, 18 ],
  ],
];

// Wraps up check for AP-s get from a different soldier for in a vehicle...
function GetUIApsToDisplay(pSoldier: SOLDIERTYPE): INT8 {
  let pVehicle: SOLDIERTYPE;

  if (pSoldier.uiStatusFlags & SOLDIER_DRIVER) {
    pVehicle = GetSoldierStructureForVehicle(pSoldier.iVehicleId);

    if (pVehicle != null) {
      return pVehicle.bActionPoints;
    } else {
      return 0;
    }
  } else {
    return pSoldier.bActionPoints;
  }
}

export function CheckForDisabledForGiveItem(): void {
  let sDist: INT16;
  let sDistVisible: INT16;
  let sDestGridNo: INT16;
  let bDestLevel: INT8;
  let cnt: INT32;
  let pSoldier: SOLDIERTYPE;
  let ubSrcSoldier: UINT8;

  Assert(gpSMCurrentMerc != null);

  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
    gfSMDisableForItems = !CanMercInteractWithSelectedShopkeeper(gpSMCurrentMerc);
    return;
  }

  // Default to true
  gfSMDisableForItems = true;

  // ATE: Is the current merc unconscious.....
  if (gpSMCurrentMerc.bLife < OKLIFE && gpItemPointer != null) {
    // Go through each merc and see if there is one closeby....
    cnt = gTacticalStatus.Team[gbPlayerNum].bFirstID;
    for (pSoldier = MercPtrs[cnt]; cnt <= gTacticalStatus.Team[gbPlayerNum].bLastID; cnt++, pSoldier = MercPtrs[cnt]) {
      if (pSoldier.bActive && pSoldier.bLife >= OKLIFE && !(pSoldier.uiStatusFlags & SOLDIER_VEHICLE) && !AM_A_ROBOT(pSoldier) && pSoldier.bInSector && IsMercOnCurrentSquad(pSoldier)) {
        sDist = PythSpacesAway(gpSMCurrentMerc.sGridNo, pSoldier.sGridNo);

        sDistVisible = DistanceVisible(pSoldier, Enum245.DIRECTION_IRRELEVANT, Enum245.DIRECTION_IRRELEVANT, gpSMCurrentMerc.sGridNo, gpSMCurrentMerc.bLevel);

        // Check LOS....
        if (SoldierTo3DLocationLineOfSightTest(pSoldier, gpSMCurrentMerc.sGridNo, gpSMCurrentMerc.bLevel, 3, sDistVisible, true)) {
          if (sDist <= PASSING_ITEM_DISTANCE_NOTOKLIFE) {
            gfSMDisableForItems = false;
            break; // found one, no need to keep looking
          }
        }
      }
    }
  } else {
    ubSrcSoldier = gusSelectedSoldier;

    if (gpItemPointer != null) {
      ubSrcSoldier = gpItemPointerSoldier.ubID;
    }

    // OK buddy, check our currently selected merc and disable/enable if not close enough...
    if (ubSrcSoldier != NOBODY) {
      if (gusSMCurrentMerc != ubSrcSoldier) {
        sDestGridNo = MercPtrs[gusSMCurrentMerc].sGridNo;
        bDestLevel = MercPtrs[gusSMCurrentMerc].bLevel;

        // Get distance....
        sDist = PythSpacesAway(MercPtrs[ubSrcSoldier].sGridNo, sDestGridNo);

        // is he close enough to see that gridno if he turns his head?
        sDistVisible = DistanceVisible(MercPtrs[ubSrcSoldier], Enum245.DIRECTION_IRRELEVANT, Enum245.DIRECTION_IRRELEVANT, sDestGridNo, bDestLevel);

        // Check LOS....
        if (SoldierTo3DLocationLineOfSightTest(MercPtrs[ubSrcSoldier], sDestGridNo, bDestLevel, 3, sDistVisible, true)) {
          // UNCONSCIOUS GUYS ONLY 1 tile AWAY
          if (MercPtrs[gusSMCurrentMerc].bLife < CONSCIOUSNESS) {
            if (sDist <= PASSING_ITEM_DISTANCE_NOTOKLIFE) {
              gfSMDisableForItems = false;
            }
          } else if (sDist <= PASSING_ITEM_DISTANCE_OKLIFE) {
            gfSMDisableForItems = false;
          }
        }
      } else {
        gfSMDisableForItems = false;
      }
    } else {
      gfSMDisableForItems = false;
    }
  }
}

export function SetSMPanelCurrentMerc(ubNewID: UINT8): void {
  gubSelectSMPanelToMerc = NOBODY;

  gusSMCurrentMerc = ubNewID;

  gpSMCurrentMerc = MercPtrs[ubNewID];

  // Set to current guy's interface level
  // if ( gsInterfaceLevel != gpSMCurrentMerc->bUIInterfaceLevel )
  //{
  //	SetRenderFlags(RENDER_FLAG_FULL);
  //	ErasePath(FALSE);
  //	gsInterfaceLevel = gpSMCurrentMerc->bUIInterfaceLevel;
  //}

  // Disable all faces
  SetAllAutoFacesInactive();

  // Turn off compat ammo....
  if (gpItemPointer == null) {
    HandleCompatibleAmmoUI(gpSMCurrentMerc, Enum261.HANDPOS, false);
    gfCheckForMouseOverItem = false;
  } else {
    // Turn it all false first....
    InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, false);
    InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, true);
  }

  // Remove item desc panel if one up....
  if (gfInItemDescBox) {
    DeleteItemDescriptionBox();
  }

  if (gfInItemPickupMenu) {
    gfSMDisableForItems = true;
  } else {
    if ((gpItemPointer != null || guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE || gpSMCurrentMerc.bLife < OKLIFE)) {
      CheckForDisabledForGiveItem();
    } else {
      gfSMDisableForItems = false;
    }
  }

  if (gpItemPointer != null) {
    ReevaluateItemHatches(gpSMCurrentMerc, false);
  }

  DisableInvRegions(gfSMDisableForItems);

  fInterfacePanelDirty = DIRTYLEVEL2;

  gfUIStanceDifferent = true;

  UpdateSMPanel();
}

export function UpdateForContOverPortrait(pSoldier: SOLDIERTYPE, fOn: boolean): void {
  let cnt: INT32;

  if (gsCurInterfacePanel == Enum215.SM_PANEL) {
    if (gpSMCurrentMerc != null) {
      // Check if mouse is in region and if so, adjust...
      if (IsMouseInRegion(gSM_SELMERCPanelRegion)) {
        HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, fOn);
      }
    }
  } else {
    for (cnt = 0; cnt < 6; cnt++) {
      if (gTeamPanel[cnt].ubID == pSoldier.ubID) {
        if (IsMouseInRegion(gTEAM_FaceRegions[cnt])) {
          HandleMouseOverSoldierFaceForContMove(pSoldier, fOn);
        }
      }
    }
  }
}

function UpdateSMPanel(): void {
  let fNearHeigherLevel: boolean;
  let fNearLowerLevel: boolean;
  let ubStanceState: UINT8;

  if (gpSMCurrentMerc.sGridNo == NOWHERE) {
    return;
  }

  // Stance
  ubStanceState = gpSMCurrentMerc.ubDesiredHeight;

  if (ubStanceState == NO_DESIRED_HEIGHT) {
    ubStanceState = gAnimControl[gpSMCurrentMerc.usAnimState].ubEndHeight;
  }

  switch (ubStanceState) {
    case ANIM_STAND:

      gbSMCurStanceObj = 0;
      DisableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
      EnableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);

      // Disable if we cannot do this!
      if (!IsValidStance(gpSMCurrentMerc, ANIM_CROUCH)) {
        DisableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
      }
      break;

    case ANIM_PRONE:
      gbSMCurStanceObj = 2;
      DisableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
      EnableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
      break;

    case ANIM_CROUCH:
      gbSMCurStanceObj = 1;
      EnableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
      EnableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);

      // Disable if we cannot do this!
      if (!IsValidStance(gpSMCurrentMerc, ANIM_PRONE)) {
        DisableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
      }
      break;
  }

  // Stance button done wether we're disabled or not...
  if (gfUIStanceDifferent) {
    // Remove old
    if (giSMStealthButton != -1) {
      RemoveButton(giSMStealthButton);
    }
    if (giSMStealthImages != -1) {
      UnloadButtonImage(giSMStealthImages);
    }

    // Make new
    giSMStealthImages = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCE_IMAGES], gbStanceButPos[Number(gpSMCurrentMerc.bStealthMode)][gbSMCurStanceObj][0], gbStanceButPos[Number(gpSMCurrentMerc.bStealthMode)][gbSMCurStanceObj][1], -1, gbStanceButPos[Number(gpSMCurrentMerc.bStealthMode)][gbSMCurStanceObj][2], -1);

    giSMStealthButton = QuickCreateButton(giSMStealthImages, SM_STEALTHMODE_X, SM_STEALTHMODE_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnStealthModeCallback);

    SetButtonFastHelpText(giSMStealthButton, TacticalStr[Enum335.TOGGLE_STEALTH_MODE_POPUPTEXT]);

    gfUIStanceDifferent = false;

    if (gfAllDisabled) {
      if (giSMStealthButton != -1) {
        DisableButton(giSMStealthButton);
      }
    }
  }

  if (gfAllDisabled) {
    return;
  }

  CheckForReEvaluateDisabledINVPanelButtons();

  // Check for any newly added items we need.....
  if (gpSMCurrentMerc.fCheckForNewlyAddedItems) {
    // Startup any newly added items....
    CheckForAnyNewlyAddedItems(gpSMCurrentMerc);

    gpSMCurrentMerc.fCheckForNewlyAddedItems = false;
  }

  // Set Disable /Enable UI based on buddy's stats
  if (ButtonList[iSMPanelButtons[Enum220.BURSTMODE_BUTTON]].ImageNum != iBurstButtonImages[gpSMCurrentMerc.bWeaponMode]) {
    ButtonList[iSMPanelButtons[Enum220.BURSTMODE_BUTTON]].ImageNum = iBurstButtonImages[gpSMCurrentMerc.bWeaponMode];
    ButtonList[iSMPanelButtons[Enum220.BURSTMODE_BUTTON]].uiFlags |= BUTTON_DIRTY;
  }

  /*
  if ( gpSMCurrentMerc->bDoBurst )
  {
          if ( !ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->ubToggleButtonActivated )
          {
                  ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->uiFlags |= BUTTON_CLICKED_ON;
          }
  }
  else
  {
          if ( !ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->ubToggleButtonActivated )
          {
                  ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->uiFlags &= ( ~BUTTON_CLICKED_ON );
          }
  }
  */

  // Toggle MUTE button...
  if (gpSMCurrentMerc.uiStatusFlags & SOLDIER_MUTE) {
    if (!ButtonList[iSMPanelButtons[Enum220.MUTE_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.MUTE_BUTTON]].uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[Enum220.MUTE_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.MUTE_BUTTON]].uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  DisableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);

  ({ fNearLowerLevel, fNearHeigherLevel } = GetMercClimbDirection(gpSMCurrentMerc.ubID));

  if (fNearLowerLevel || fNearHeigherLevel) {
    if (fNearLowerLevel) {
      if (EnoughPoints(gpSMCurrentMerc, GetAPsToClimbRoof(gpSMCurrentMerc, true), 0, false)) {
        EnableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
      }
    }

    if (fNearHeigherLevel) {
      if (EnoughPoints(gpSMCurrentMerc, GetAPsToClimbRoof(gpSMCurrentMerc, false), 0, false)) {
        EnableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
      }
    }
  }

  if (FindFenceJumpDirection(gpSMCurrentMerc, gpSMCurrentMerc.sGridNo, gpSMCurrentMerc.bDirection, null)) {
    EnableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
  }

  if ((gTacticalStatus.ubCurrentTeam != gbPlayerNum) || (gTacticalStatus.uiFlags & REALTIME) || !(gTacticalStatus.uiFlags & INCOMBAT)) {
    DisableButton(iSMPanelButtons[Enum220.SM_DONE_BUTTON]);
  } else if (!gfAllDisabled) {
    EnableButton(iSMPanelButtons[Enum220.SM_DONE_BUTTON]);
  }

  //	if ( gpSMCurrentMerc->bUIInterfaceLevel > 0 )
  if (gsInterfaceLevel > 0) {
    if (!ButtonList[iSMPanelButtons[Enum220.UPDOWN_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.UPDOWN_BUTTON]].uiFlags |= (BUTTON_CLICKED_ON);
    }
  } else {
    if (!ButtonList[iSMPanelButtons[Enum220.UPDOWN_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.UPDOWN_BUTTON]].uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  if (gCurrentUIMode == Enum206.HANDCURSOR_MODE) {
    if (!ButtonList[iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]].uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]].uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  if (gCurrentUIMode == Enum206.TALKCURSOR_MODE) {
    if (!ButtonList[iSMPanelButtons[Enum220.TALK_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.TALK_BUTTON]].uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[Enum220.TALK_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.TALK_BUTTON]].uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  if (gCurrentUIMode == Enum206.LOOKCURSOR_MODE) {
    if (!ButtonList[iSMPanelButtons[Enum220.LOOK_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.LOOK_BUTTON]].uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[Enum220.LOOK_BUTTON]].ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[Enum220.LOOK_BUTTON]].uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  // If not selected ( or dead ), disable/gray some buttons
  if (gusSelectedSoldier != gpSMCurrentMerc.ubID || (gpSMCurrentMerc.bLife < OKLIFE) || (gTacticalStatus.ubCurrentTeam != gbPlayerNum) || gfSMDisableForItems) {
    DisableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.BURSTMODE_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.LOOK_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.UPDOWN_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]);
    if (giSMStealthButton != -1) {
      DisableButton(giSMStealthButton);
    }
  } else {
    // Enable some buttons!
    if (IsGunBurstCapable(gpSMCurrentMerc, Enum261.HANDPOS, false) || FindAttachment(gpSMCurrentMerc.inv[Enum261.HANDPOS], Enum225.UNDER_GLAUNCHER) != ITEM_NOT_FOUND) {
      EnableButton(iSMPanelButtons[Enum220.BURSTMODE_BUTTON]);
    } else {
      DisableButton(iSMPanelButtons[Enum220.BURSTMODE_BUTTON]);
    }
    EnableButton(iSMPanelButtons[Enum220.LOOK_BUTTON]);
    EnableButton(iSMPanelButtons[Enum220.UPDOWN_BUTTON]);
    EnableButton(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]);

    if (giSMStealthButton != -1) {
      EnableButton(giSMStealthButton);
    }
  }

  // CJC Dec 4 2002: or if item pickup menu is up
  if ((gTacticalStatus.uiFlags & ENGAGED_IN_CONV) || gfInItemPickupMenu) {
    DisableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);
  } else {
    EnableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);
  }
}

export function ReevaluateItemHatches(pSoldier: SOLDIERTYPE, fAllValid: boolean): void {
  let cnt: INT32;

  // if there's an item in the cursor and we're not supposed to just make them all valid
  if ((gpItemPointer != null) && !fAllValid) {
    // check all inventory positions and mark the ones where cursor item won't fit as invalid
    for (cnt = 0; cnt < Enum261.NUM_INV_SLOTS; cnt++) {
      gbInvalidPlacementSlot[cnt] = !CanItemFitInPosition(pSoldier, gpItemPointer, cnt, false);

      // !!! ATTACHING/MERGING ITEMS IN MAP SCREEN IS NOT SUPPORTED !!!
      // CJC: seems to be supported now...
      // if( guiCurrentScreen != MAP_SCREEN )
      {
        // Check attachments, override to valid placement if valid merge...
        if (ValidAttachment(gpItemPointer.usItem, pSoldier.inv[cnt].usItem)) {
          gbInvalidPlacementSlot[cnt] = false;
        }

        if (ValidMerge(gpItemPointer.usItem, pSoldier.inv[cnt].usItem)) {
          gbInvalidPlacementSlot[cnt] = false;
        }
      }
    }
  } else {
    // mark all inventory positions as valid
    for (cnt = 0; cnt < Enum261.NUM_INV_SLOTS; cnt++) {
      gbInvalidPlacementSlot[cnt] = false;
    }
  }

  fInterfacePanelDirty = DIRTYLEVEL2;
}

export function EnableSMPanelButtons(fEnable: boolean, fFromItemPickup: boolean): void {
  if (fFromItemPickup) {
    // If we have the item pointer up...
    // CJC Dec 4 2002: or if item pickup menu is up
    // if ( gpItemPointer != NULL )
    if (gpItemPointer != null || gfInItemPickupMenu) {
      DisableTacticalTeamPanelButtons(true);
    } else {
      DisableTacticalTeamPanelButtons(false);
    }

    fInterfacePanelDirty = DIRTYLEVEL2;
  }

  if (gsCurInterfacePanel == Enum215.SM_PANEL) {
    if (fFromItemPickup) {
      // If we have the item pointer up...
      if (gpItemPointer != null) {
        ReevaluateItemHatches(gpSMCurrentMerc, fEnable);

        // Turn it all false first....
        InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, false);
        InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, true);

        gfCheckForMouseOverItem = false;

        // Highlight guys ....
        HandleAnyMercInSquadHasCompatibleStuff(CurrentSquad(), gpItemPointer, false);
      } else {
        // InternalHandleCompatibleAmmoUI( gpSMCurrentMerc, gpItemPointer, FALSE );
        gfCheckForMouseOverItem = false;

        HandleAnyMercInSquadHasCompatibleStuff(CurrentSquad(), null, true);
      }

      if (fEnable) {
        ReevaluateItemHatches(gpSMCurrentMerc, fEnable);
      }

      fInterfacePanelDirty = DIRTYLEVEL2;
    }

    if (fEnable) {
      // only enable the following if NOT in shopkeeper's interface
      if (!(guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)) {
        EnableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
        EnableButton(iSMPanelButtons[Enum220.BURSTMODE_BUTTON]);
        EnableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
        EnableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
        EnableButton(iSMPanelButtons[Enum220.LOOK_BUTTON]);
        EnableButton(iSMPanelButtons[Enum220.UPDOWN_BUTTON]);
        EnableButton(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]);
        if (giSMStealthButton != -1) {
          EnableButton(giSMStealthButton);
        }

        if (gfDisableTacticalPanelButtons) {
          DisableButton(iSMPanelButtons[Enum220.OPTIONS_BUTTON]);
          DisableButton(iSMPanelButtons[Enum220.SM_DONE_BUTTON]);
          DisableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);
        } else {
          EnableButton(iSMPanelButtons[Enum220.OPTIONS_BUTTON]);
          EnableButton(iSMPanelButtons[Enum220.SM_DONE_BUTTON]);
          EnableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);
        }

        // enable the radar map region
        MSYS_EnableRegion(gRadarRegion);

        gfSMDisableForItems = false;

        DisableInvRegions(gfSMDisableForItems);
      }

      if (!fFromItemPickup) {
        EnableButton(iSMPanelButtons[Enum220.NEXTMERC_BUTTON]);
        EnableButton(iSMPanelButtons[Enum220.PREVMERC_BUTTON]);
      }
    } else {
      DisableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.BURSTMODE_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.LOOK_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.UPDOWN_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]);
      if (giSMStealthButton != -1) {
        DisableButton(giSMStealthButton);
      }

      if (!fFromItemPickup) {
        DisableButton(iSMPanelButtons[Enum220.NEXTMERC_BUTTON]);
        DisableButton(iSMPanelButtons[Enum220.PREVMERC_BUTTON]);
      }

      DisableButton(iSMPanelButtons[Enum220.OPTIONS_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.SM_DONE_BUTTON]);
      DisableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);

      // disable the radar map
      MSYS_DisableRegion(gRadarRegion);
    }

    gfAllDisabled = !fEnable;
  }
}

export function GetSMPanelCurrentMerc(): UINT16 {
  return gusSMCurrentMerc;
}

export function InitializeSMPanel(): boolean {
  let VObjectDesc: VOBJECT_DESC = createVObjectDesc();

  // failing the CHECKF after this will cause you to lose your mouse
  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = "INTERFACE\\inventory_bottom_panel.STI";
  if (!(guiSMPanel = AddVideoObject(VObjectDesc))) {
    return false;
  }

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = FilenameForBPP("INTERFACE\\inventory_gold_front.sti");
  if (!(guiSMObjects = AddVideoObject(VObjectDesc))) {
    return false;
  }

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = FilenameForBPP("INTERFACE\\inv_frn.sti");
  if (!(guiSMObjects2 = AddVideoObject(VObjectDesc))) {
    return false;
  }

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = FilenameForBPP("INTERFACE\\secondary_gun_hidden.sti");
  if (!(guiSecItemHiddenVO = AddVideoObject(VObjectDesc))) {
    return false;
  }

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = FilenameForBPP("INTERFACE\\Bars.sti");
  if (!(guiBrownBackgroundForTeamPanel = AddVideoObject(VObjectDesc))) {
    return false;
  }

  // Clear inv display stuff
  gfSM_HandInvDispText.fill(false);

  // INit viewport region
  // Set global mouse regions
  // Define region for viewport
  MSYS_DefineRegion(gViewportRegion, 0, 0, gsVIEWPORT_END_X, gsVIEWPORT_WINDOW_END_Y, MSYS_PRIORITY_NORMAL, VIDEO_NO_CURSOR, MSYS_NO_CALLBACK, MSYS_NO_CALLBACK);
  // Add region
  MSYS_AddRegion(gViewportRegion);

  // Create buttons
  if (!CreateSMPanelButtons()) {
    return false;
  }

  // Set viewports
  // Define region for panel
  MSYS_DefineRegion(gSMPanelRegion, 0, INV_INTERFACE_START_Y, 640, 480, MSYS_PRIORITY_NORMAL, Enum317.CURSOR_NORMAL, MSYS_NO_CALLBACK, InvPanelButtonClickCallback);
  // Add region
  MSYS_AddRegion(gSMPanelRegion);

  // DEfine region for selected guy panel
  MSYS_DefineRegion(gSM_SELMERCPanelRegion, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, SM_SELMERC_FACE_X + SM_SELMERC_FACE_WIDTH, SM_SELMERC_FACE_Y + SM_SELMERC_FACE_HEIGHT, MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, SelectedMercButtonMoveCallback, SelectedMercButtonCallback);
  // Add region
  MSYS_AddRegion(gSM_SELMERCPanelRegion);

  // DEfine region for selected guy panel
  MSYS_DefineRegion(gSM_SELMERCEnemyIndicatorRegion, SM_SELMERC_FACE_X + 1, SM_SELMERC_FACE_Y + 1, SM_SELMERC_FACE_X + INDICATOR_BOX_WIDTH, SM_SELMERC_FACE_Y + INDICATOR_BOX_HEIGHT, MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, SelectedMercEnemyIndicatorCallback);
  // Add region
  MSYS_AddRegion(gSM_SELMERCEnemyIndicatorRegion);

  // DEfine region for money button
  MSYS_DefineRegion(gSM_SELMERCMoneyRegion, MONEY_X, MONEY_Y, MONEY_X + MONEY_WIDTH, MONEY_Y + MONEY_HEIGHT, MSYS_PRIORITY_HIGH, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, SMInvMoneyButtonCallback);
  // Add region
  MSYS_AddRegion(gSM_SELMERCMoneyRegion);

  SetRegionFastHelpText(gSM_SELMERCMoneyRegion, TacticalStr[Enum335.MONEY_BUTTON_HELP_TEXT]);

  // Check if mouse is in region and if so, adjust...
  if (IsMouseInRegion(gSM_SELMERCPanelRegion)) {
    HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, true);
  }

  // DEfine region for selected guy panel
  MSYS_DefineRegion(gSM_SELMERCBarsRegion, 62, 342, 85, 391, MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, SelectedMercButtonCallback);
  // Add region
  MSYS_AddRegion(gSM_SELMERCBarsRegion);

  InitInvSlotInterface(gSMInvPocketXY, gSMCamoXY, SMInvMoveCallback, SMInvClickCallback, SMInvMoveCammoCallback, SMInvClickCamoCallback, false);

  InitKeyRingInterface(KeyRingItemPanelButtonCallback);

  // this is important! It will disable buttons like SM_MAP_SCREEN_BUTTON when they're supposed to be disabled - the previous
  // disabled state is lost everytime panel is reinitialized, because all the buttons are created from scratch!
  if (gpItemPointer == null) {
    // empty cursor - enable, not from item pickup
    EnableSMPanelButtons(true, false);
  } else {
    // full cursor - disable, from item pickup
    EnableSMPanelButtons(false, true);
  }

  return true;
}

export function CreateSMPanelButtons(): boolean {
  let ubString: string /* UINT8[48] */;

  giSMStealthImages = -1;
  giSMStealthButton = -1;
  gfUIStanceDifferent = true;
  gfAllDisabled = false;

  ubString = FilenameForBPP("INTERFACE\\inventory_buttons.sti");
  // Load button Graphics
  iSMPanelImages[Enum218.STANCEUP_IMAGES] = LoadButtonImage(ubString, -1, 0, -1, 10, -1);

  iSMPanelImages[Enum218.UPDOWN_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 9, -1, 19, -1);
  iSMPanelImages[Enum218.CLIMB_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 3, -1, 13, -1);
  iSMPanelImages[Enum218.STANCEDOWN_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 8, -1, 18, -1);
  iSMPanelImages[Enum218.HANDCURSOR_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 1, -1, 11, -1);
  iSMPanelImages[Enum218.PREVMERC_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 20, -1, 22, -1);
  iSMPanelImages[Enum218.NEXTMERC_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 21, -1, 23, -1);
  // iSMPanelImages[ BURSTMODE_IMAGES  ]			= UseLoadedButtonImage( iSMPanelImages[ STANCEUP_IMAGES  ] ,-1,7,-1,17,-1 );
  iSMPanelImages[Enum218.LOOK_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 2, -1, 12, -1);
  iSMPanelImages[Enum218.TALK_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 6, -1, 16, -1);
  iSMPanelImages[Enum218.MUTE_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 5, -1, 15, -1);
  iSMPanelImages[Enum218.OPTIONS_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 24, -1, 25, -1);

  iBurstButtonImages[Enum265.WM_NORMAL] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 7, -1, -1, -1);
  iBurstButtonImages[Enum265.WM_BURST] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 17, -1, -1, -1);
  iBurstButtonImages[Enum265.WM_ATTACHED] = UseLoadedButtonImage(iSMPanelImages[Enum218.STANCEUP_IMAGES], -1, 26, -1, -1, -1);

  ubString = FilenameForBPP("INTERFACE\\invadd-ons.sti");
  // Load button Graphics
  iSMPanelImages[Enum218.STANCE_IMAGES] = LoadButtonImage(ubString, 0, 0, -1, 2, -1);

  ubString = FilenameForBPP("INTERFACE\\inventory_buttons_2.sti");
  // Load button Graphics
  iSMPanelImages[Enum218.DONE_IMAGES] = LoadButtonImage(ubString, -1, 1, -1, 3, -1);
  iSMPanelImages[Enum218.MAPSCREEN_IMAGES] = UseLoadedButtonImage(iSMPanelImages[Enum218.DONE_IMAGES], -1, 0, -1, 2, -1);

  // Create buttons

  // SET BUTTONS TO -1
  iSMPanelButtons.fill(-1);

  iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.MAPSCREEN_IMAGES], SM_MAPSCREEN_X, SM_MAPSCREEN_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnMapScreenCallback);
  SetButtonFastHelpText(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON], TacticalStr[Enum335.MAPSCREEN_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.SM_DONE_BUTTON] = CreateIconAndTextButton(iSMPanelImages[Enum218.DONE_IMAGES], "", FONT12ARIAL(), FONT_MCOLOR_WHITE, DEFAULT_SHADOW, FONT_MCOLOR_WHITE, DEFAULT_SHADOW, TEXT_CJUSTIFIED, SM_DONE_X, SM_DONE_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnSMDoneCallback);
  SetButtonFastHelpText(iSMPanelButtons[Enum220.SM_DONE_BUTTON], TacticalStr[Enum335.END_TURN_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.SM_DONE_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.TALK_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.TALK_IMAGES], SM_TALKB_X, SM_TALKB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnTalkCallback);
  SetButtonFastHelpText(iSMPanelButtons[Enum220.TALK_BUTTON], TacticalStr[Enum335.TALK_CURSOR_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.TALK_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.MUTE_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.MUTE_IMAGES], SM_MUTEB_X, SM_MUTEB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnMuteCallback);
  SetButtonFastHelpText(iSMPanelButtons[Enum220.MUTE_BUTTON], TacticalStr[Enum335.TOGGLE_MUTE_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.MUTE_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.STANCEUP_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.STANCEUP_IMAGES], SM_STANCEUPB_X, SM_STANCEUPB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnStanceUpCallback);
  if (iSMPanelButtons[Enum220.STANCEUP_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  SetButtonFastHelpText(iSMPanelButtons[Enum220.STANCEUP_BUTTON], TacticalStr[Enum335.CHANGE_STANCE_UP_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.STANCEUP_BUTTON], HelpTextDoneCallback);

  // SetButtonFastHelpText( iSMPanelButtons[ STANCEUP_BUTTON ],L"Change Stance Up");

  iSMPanelButtons[Enum220.UPDOWN_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.UPDOWN_IMAGES], SM_UPDOWNB_X, SM_UPDOWNB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnUpdownCallback);
  if (iSMPanelButtons[Enum220.UPDOWN_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ UPDOWN_BUTTON ],L"Whatever");
  SetButtonFastHelpText(iSMPanelButtons[Enum220.UPDOWN_BUTTON], TacticalStr[Enum335.CURSOR_LEVEL_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.UPDOWN_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.CLIMB_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.CLIMB_IMAGES], SM_CLIMBB_X, SM_CLIMBB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnClimbCallback);
  if (iSMPanelButtons[Enum220.CLIMB_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ CLIMB_BUTTON ],L"Climb");
  SetButtonFastHelpText(iSMPanelButtons[Enum220.CLIMB_BUTTON], TacticalStr[Enum335.JUMPCLIMB_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.CLIMB_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.STANCEDOWN_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.STANCEDOWN_IMAGES], SM_STANCEDOWNB_X, SM_STANCEDOWNB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnStanceDownCallback);
  if (iSMPanelButtons[Enum220.STANCEDOWN_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ STANCEDOWN_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON], TacticalStr[Enum335.CHANGE_STANCE_DOWN_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.HANDCURSOR_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.HANDCURSOR_IMAGES], SM_HANDCURSORB_X, SM_HANDCURSORB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnHandCursorCallback);
  if (iSMPanelButtons[Enum220.HANDCURSOR_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ HANDCURSOR_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON], TacticalStr[Enum335.EXAMINE_CURSOR_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.PREVMERC_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.PREVMERC_IMAGES], SM_PREVMERCB_X, SM_PREVMERCB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnPrevMercCallback);
  if (iSMPanelButtons[Enum220.PREVMERC_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ PREVMERC_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[Enum220.PREVMERC_BUTTON], TacticalStr[Enum335.PREV_MERC_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.PREVMERC_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.NEXTMERC_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.NEXTMERC_IMAGES], SM_NEXTMERCB_X, SM_NEXTMERCB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnNextMercCallback);
  if (iSMPanelButtons[Enum220.NEXTMERC_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  SetButtonFastHelpText(iSMPanelButtons[Enum220.NEXTMERC_BUTTON], TacticalStr[Enum335.NEXT_MERC_POPUPTEXT]);
  // SetButtonFastHelpText( iSMPanelButtons[ NEXTMERC_BUTTON ],L"Change Stance Down");
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.NEXTMERC_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.OPTIONS_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.OPTIONS_IMAGES], SM_OPTIONSB_X, SM_OPTIONSB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnOptionsCallback);
  if (iSMPanelButtons[Enum220.OPTIONS_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ OPTIONS_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[Enum220.OPTIONS_BUTTON], TacticalStr[Enum335.CHANGE_OPTIONS_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.OPTIONS_BUTTON], HelpTextDoneCallback);

  /*iSMPanelButtons[ BURSTMODE_BUTTON ] = QuickCreateButton( iSMPanelImages[ BURSTMODE_IMAGES ], SM_BURSTMODEB_X, SM_BURSTMODEB_Y,
                                                                          BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1,
                                                                          MSYS_NO_CALLBACK, (GUI_CALLBACK)BtnBurstModeCallback );*/
  iSMPanelButtons[Enum220.BURSTMODE_BUTTON] = QuickCreateButton(iBurstButtonImages[Enum265.WM_NORMAL], SM_BURSTMODEB_X, SM_BURSTMODEB_Y, BUTTON_NO_TOGGLE, MSYS_PRIORITY_HIGH, MSYS_NO_CALLBACK, BtnBurstModeCallback);

  if (iSMPanelButtons[Enum220.BURSTMODE_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  SetButtonFastHelpText(iSMPanelButtons[Enum220.BURSTMODE_BUTTON], TacticalStr[Enum335.TOGGLE_BURSTMODE_POPUPTEXT]);
  // SetButtonFastHelpText( iSMPanelButtons[ BURSTMODE_BUTTON ],L"Change Stance Down");
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.BURSTMODE_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[Enum220.LOOK_BUTTON] = QuickCreateButton(iSMPanelImages[Enum218.LOOK_IMAGES], SM_LOOKB_X, SM_LOOKB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnLookCallback);
  if (iSMPanelButtons[Enum220.LOOK_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ LOOK_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[Enum220.LOOK_BUTTON], TacticalStr[Enum335.LOOK_CURSOR_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[Enum220.LOOK_BUTTON], HelpTextDoneCallback);

  return true;
}

export function RemoveSMPanelButtons(): void {
  let cnt: UINT32;

  for (cnt = 0; cnt < Enum220.NUM_SM_BUTTONS; cnt++) {
    if (iSMPanelButtons[cnt] != -1) {
      RemoveButton(iSMPanelButtons[cnt]);
    }
  }

  for (cnt = 0; cnt < Enum218.NUM_SM_BUTTON_IMAGES; cnt++) {
    UnloadButtonImage(iSMPanelImages[cnt]);
  }

  if (giSMStealthButton != -1) {
    RemoveButton(giSMStealthButton);
  }

  if (giSMStealthImages != -1) {
    UnloadButtonImage(giSMStealthImages);
  }

  UnloadButtonImage(iBurstButtonImages[Enum265.WM_NORMAL]);
  UnloadButtonImage(iBurstButtonImages[Enum265.WM_BURST]);
  UnloadButtonImage(iBurstButtonImages[Enum265.WM_ATTACHED]);
}

export function ShutdownSMPanel(): boolean {
  // All buttons and regions and video objects and video surfaces will be deleted at shutddown of SGM
  // We may want to delete them at the interm as well, to free up room for other panels
  DeleteVideoObjectFromIndex(guiSMPanel);
  DeleteVideoObjectFromIndex(guiSMObjects);
  DeleteVideoObjectFromIndex(guiSMObjects2);
  DeleteVideoObjectFromIndex(guiSecItemHiddenVO);
  DeleteVideoObjectFromIndex(guiBrownBackgroundForTeamPanel);

  gubSelectSMPanelToMerc = NOBODY;

  // CJC: delete key ring if open
  DeleteKeyRingPopup(); // function will abort if key ring is not up

  // ATE: Delete desc panel if it was open....
  if (gfInItemDescBox) {
    DeleteItemDescriptionBox();
  }

  // Shotdown item slot interface
  ShutdownInvSlotInterface();

  // shutdown keyring interface
  ShutdownKeyRingInterface();

  MSYS_RemoveRegion(gSMPanelRegion);
  MSYS_RemoveRegion(gSM_SELMERCPanelRegion);
  MSYS_RemoveRegion(gSM_SELMERCBarsRegion);
  MSYS_RemoveRegion(gSM_SELMERCMoneyRegion);
  MSYS_RemoveRegion(gSM_SELMERCEnemyIndicatorRegion);

  HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, false);

  MSYS_RemoveRegion(gViewportRegion);

  RemoveSMPanelButtons();

  return true;
}

/* static */ let RenderSMPanel__pStr: string /* INT16[200] */;
/* static */ let RenderSMPanel__pMoraleStr: string /* INT16[20] */;
export function RenderSMPanel(pfDirty: Pointer<UINT8>): void {
  let sFontX: INT16;
  let sFontY: INT16;
  let usX: UINT16;
  let usY: UINT16;
  let sString: string /* wchar_t[9] */;
  let cnt: UINT32 = 0;

  if (gubSelectSMPanelToMerc != NOBODY) {
    // Give him the panel!
    SetSMPanelCurrentMerc(gubSelectSMPanelToMerc);
  }

  // ATE: Don't do anything if we are in stack popup and are refreshing stuff....
  if ((InItemStackPopup() || (InKeyRingPopup())) && (pfDirty.value) == DIRTYLEVEL1) {
    return;
  }

  if (gfCheckForMouseOverItem) {
    if ((GetJA2Clock() - guiMouseOverItemTime) > 100) {
      if (HandleCompatibleAmmoUI(gpSMCurrentMerc, gbCheckForMouseOverItemPos, true)) {
        (pfDirty.value) = DIRTYLEVEL2;
      }

      gfCheckForMouseOverItem = false;
    }
  }

  HandleNewlyAddedItems(gpSMCurrentMerc, pfDirty);

  if (InItemDescriptionBox()) {
    HandleItemDescriptionBox(pfDirty);
  }

  if (pfDirty.value == DIRTYLEVEL2) {
    // if ( InItemStackPopup( ) )
    //{

    //}

    if (InItemDescriptionBox()) {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMPanel, 0, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, null);
      RenderSoldierFace(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, true);

      // ATE: Need these lines here to fix flash bug with face selection box
      if (gfSMDisableForItems) {
        BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects2, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, null);
        RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
      } else {
        if (gusSelectedSoldier == gpSMCurrentMerc.ubID && gTacticalStatus.ubCurrentTeam == OUR_TEAM && OK_INTERRUPT_MERC(gpSMCurrentMerc)) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, null);
          RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
        }
      }

      RenderItemDescriptionBox();
    } else {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMPanel, 0, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, null);

      RenderInvBodyPanel(gpSMCurrentMerc, SM_BODYINV_X, SM_BODYINV_Y);

      // CHECK FOR PANEL STUFF / DEATHS / CLOSURES
      CheckForFacePanelStartAnims(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y);

      // Hitlight

      if (gfSMDisableForItems) {
        BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects2, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, null);
        RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
      } else {
        if (gusSelectedSoldier == gpSMCurrentMerc.ubID && gTacticalStatus.ubCurrentTeam == OUR_TEAM && OK_INTERRUPT_MERC(gpSMCurrentMerc)) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, null);
          RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
        }
      }

      SetFont(BLOCKFONT2());

      // Render Values for stats!
      // Set font drawing to saved buffer
      SetFontDestBuffer(guiSAVEBUFFER, 0, 0, 640, 480, false);

      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(STATS_TITLE_FONT_COLOR);
      for (cnt = 0; cnt < 5; cnt++) {
        mprintf(92, (347 + cnt * 10), pShortAttributeStrings[cnt]);
        mprintf(137, (347 + cnt * 10), pShortAttributeStrings[cnt + 5]);
      }

      mprintf(Math.trunc(SM_ARMOR_LABEL_X - StringPixLength(pInvPanelTitleStrings[0], BLOCKFONT2()) / 2), SM_ARMOR_LABEL_Y, pInvPanelTitleStrings[0]);
      mprintf(SM_ARMOR_PERCENT_X, SM_ARMOR_PERCENT_Y, "%");

      mprintf(SM_WEIGHT_LABEL_X - StringPixLength(pInvPanelTitleStrings[1], BLOCKFONT2()), SM_WEIGHT_LABEL_Y, pInvPanelTitleStrings[1]);
      mprintf(SM_WEIGHT_PERCENT_X, SM_WEIGHT_PERCENT_Y, "%");

      mprintf(SM_CAMMO_LABEL_X - StringPixLength(pInvPanelTitleStrings[2], BLOCKFONT2()), SM_CAMMO_LABEL_Y, pInvPanelTitleStrings[2]);
      mprintf(SM_CAMMO_PERCENT_X, SM_CAMMO_PERCENT_Y, "%");

      UpdateStatColor(gpSMCurrentMerc.uiChangeAgilityTime, (gpSMCurrentMerc.usValueGoneUp & AGIL_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bAgility.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_AGI_X, SM_AGI_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeDexterityTime, (gpSMCurrentMerc.usValueGoneUp & DEX_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bDexterity.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_DEX_X, SM_DEX_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeStrengthTime, (gpSMCurrentMerc.usValueGoneUp & STRENGTH_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bStrength.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_STR_X, SM_STR_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeLeadershipTime, (gpSMCurrentMerc.usValueGoneUp & LDR_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bLeadership.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_CHAR_X, SM_CHAR_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeWisdomTime, (gpSMCurrentMerc.usValueGoneUp & WIS_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bWisdom.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_WIS_X, SM_WIS_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeLevelTime, (gpSMCurrentMerc.usValueGoneUp & LVL_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bExpLevel.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_EXPLVL_X, SM_EXPLVL_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeMarksmanshipTime, (gpSMCurrentMerc.usValueGoneUp & MRK_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bMarksmanship.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_MRKM_X, SM_MRKM_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeExplosivesTime, (gpSMCurrentMerc.usValueGoneUp & EXP_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bExplosive.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_EXPL_X, SM_EXPL_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeMechanicalTime, (gpSMCurrentMerc.usValueGoneUp & MECH_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bMechanical.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_MECH_X, SM_MECH_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.uiChangeMedicalTime, (gpSMCurrentMerc.usValueGoneUp & MED_INCREASE ? true : false));

      sString = swprintf("%s", gpSMCurrentMerc.bMedical.toString().padStart(2));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_MED_X, SM_MED_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      if (gpSMCurrentMerc.bLife >= OKLIFE) {
        SetFontBackground(FONT_MCOLOR_BLACK);
        SetFontForeground(STATS_TEXT_FONT_COLOR);
      } else {
        SetFontBackground(FONT_MCOLOR_BLACK);
        SetFontForeground(FONT_MCOLOR_DKGRAY);
      }

      // Display armour value!
      sString = swprintf("%s", ArmourPercent(gpSMCurrentMerc).toString().padStart(3));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_ARMOR_X, SM_ARMOR_Y, SM_PERCENT_WIDTH, SM_PERCENT_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      // Display wieght value!
      sString = swprintf("%s", CalculateCarriedWeight(gpSMCurrentMerc).toString().padStart(3));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_WEIGHT_X, SM_WEIGHT_Y, SM_PERCENT_WIDTH, SM_PERCENT_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      // Display cammo value!
      sString = swprintf("%s", gpSMCurrentMerc.bCamo.toString().padStart(3));
      ({ sX: usX, sY: usY } = FindFontRightCoordinates(SM_CAMMO_X, SM_CAMMO_Y, SM_PERCENT_WIDTH, SM_PERCENT_HEIGHT, sString, BLOCKFONT2()));
      mprintf(usX, usY, sString);

      // reset to frame buffer!
      SetFontDestBuffer(FRAME_BUFFER, 0, 0, 640, 480, false);

      RestoreExternBackgroundRect(INTERFACE_START_X, INV_INTERFACE_START_Y, (640 - INTERFACE_START_X), (480 - INV_INTERFACE_START_Y));

      RenderSoldierFace(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, true);
    }

    // Render Name!
    SetFont(BLOCKFONT2());

    if (gpSMCurrentMerc.bStealthMode) {
      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(FONT_MCOLOR_LTYELLOW);
    } else {
      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(FONT_MCOLOR_LTGRAY);
    }

    RestoreExternBackgroundRect(SM_SELMERCNAME_X, SM_SELMERCNAME_Y, SM_SELMERCNAME_WIDTH, SM_SELMERCNAME_HEIGHT);
    ({ sX: sFontX, sY: sFontY } = VarFindFontCenterCoordinates(SM_SELMERCNAME_X, SM_SELMERCNAME_Y, SM_SELMERCNAME_WIDTH, SM_SELMERCNAME_HEIGHT, SMALLFONT1(), "%s", gpSMCurrentMerc.name));
    mprintf(sFontX + 5, sFontY, "%s", gpSMCurrentMerc.name);
  }

  if (pfDirty.value != DIRTYLEVEL0) {
    // UPdate stats!
    if (gpSMCurrentMerc.bLife != 0) {
      if (gpSMCurrentMerc.uiStatusFlags & SOLDIER_VEHICLE) {
        RenderSMPanel__pStr = swprintf(TacticalStr[Enum335.VEHICLE_VITAL_STATS_POPUPTEXT], gpSMCurrentMerc.bLife, gpSMCurrentMerc.bLifeMax, gpSMCurrentMerc.bBreath, gpSMCurrentMerc.bBreathMax);
        SetRegionFastHelpText(gSM_SELMERCBarsRegion, RenderSMPanel__pStr);
      } else if (gpSMCurrentMerc.uiStatusFlags & SOLDIER_ROBOT) {
        RenderSMPanel__pStr = swprintf(gzLateLocalizedString[16], gpSMCurrentMerc.bLife, gpSMCurrentMerc.bLifeMax);
        SetRegionFastHelpText(gTEAM_BarsRegions[cnt], RenderSMPanel__pStr);
      } else {
        RenderSMPanel__pMoraleStr = GetMoraleString(gpSMCurrentMerc);
        RenderSMPanel__pStr = swprintf(TacticalStr[Enum335.MERC_VITAL_STATS_POPUPTEXT], gpSMCurrentMerc.bLife, gpSMCurrentMerc.bLifeMax, gpSMCurrentMerc.bBreath, gpSMCurrentMerc.bBreathMax, RenderSMPanel__pMoraleStr);
        SetRegionFastHelpText(gSM_SELMERCBarsRegion, RenderSMPanel__pStr);
      }
    } else {
      SetRegionFastHelpText(gSM_SELMERCBarsRegion, "");
    }

    // if we are in the shop keeper interface
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
      SetRegionHelpEndCallback(gSM_SELMERCBarsRegion, SkiHelpTextDoneCallBack);

    // display AP
    if (!(gpSMCurrentMerc.uiStatusFlags & SOLDIER_DEAD)) {
      if (gTacticalStatus.uiFlags & TURNBASED && (gTacticalStatus.uiFlags & INCOMBAT) && gpSMCurrentMerc.bLife >= OKLIFE) {
        SetFont(TINYFONT1());
        // if ( gpSMCurrentMerc->sLastTarget != NOWHERE && !EnoughPoints( gpSMCurrentMerc, MinAPsToAttack( gpSMCurrentMerc, gpSMCurrentMerc->sLastTarget, FALSE ), 0, FALSE ) || GetUIApsToDisplay( gpSMCurrentMerc ) < 0 )
        if (!EnoughPoints(gpSMCurrentMerc, MinAPsToAttack(gpSMCurrentMerc, gpSMCurrentMerc.sLastTarget, 0), 0, false) || GetUIApsToDisplay(gpSMCurrentMerc) < 0) {
          SetFontBackground(FONT_MCOLOR_BLACK);
          SetFontForeground(FONT_MCOLOR_DKRED);
        } else {
          if (MercUnderTheInfluence(gpSMCurrentMerc)) {
            SetFontBackground(FONT_MCOLOR_BLACK);
            SetFontForeground(FONT_MCOLOR_LTBLUE);
          } else if (gpSMCurrentMerc.bStealthMode) {
            SetFontBackground(FONT_MCOLOR_BLACK);
            SetFontForeground(FONT_MCOLOR_LTYELLOW);
          } else {
            SetFontBackground(FONT_MCOLOR_BLACK);
            SetFontForeground(FONT_MCOLOR_LTGRAY);
          }
        }

        gprintfRestore(SM_SELMERC_AP_X, SM_SELMERC_AP_Y, "%s", GetUIApsToDisplay(gpSMCurrentMerc).toString().padStart(2));
        ({ sX: sFontX, sY: sFontY } = VarFindFontCenterCoordinates(SM_SELMERC_AP_X, SM_SELMERC_AP_Y, SM_SELMERC_AP_WIDTH, SM_SELMERC_AP_HEIGHT, TINYFONT1(), "%d", GetUIApsToDisplay(gpSMCurrentMerc)));
        mprintf(sFontX, SM_SELMERC_AP_Y, "%d", GetUIApsToDisplay(gpSMCurrentMerc));
      }

      // Display bars
      DrawLifeUIBarEx(gpSMCurrentMerc, SM_SELMERC_HEALTH_X, SM_SELMERC_HEALTH_Y, SM_SELMERC_HEALTH_WIDTH, SM_SELMERC_HEALTH_HEIGHT, true, FRAME_BUFFER);

      if (!(gpSMCurrentMerc.uiStatusFlags & SOLDIER_ROBOT)) {
        DrawBreathUIBarEx(gpSMCurrentMerc, SM_SELMERC_BREATH_X, SM_SELMERC_BREATH_Y, SM_SELMERC_HEALTH_WIDTH, SM_SELMERC_HEALTH_HEIGHT, true, FRAME_BUFFER);
        DrawMoraleUIBarEx(gpSMCurrentMerc, SM_SELMERC_MORALE_X, SM_SELMERC_MORALE_Y, SM_SELMERC_MORALE_WIDTH, SM_SELMERC_MORALE_HEIGHT, true, FRAME_BUFFER);
      }
    }
  }

  UpdateSMPanel();

  // HandlePanelFaceAnimations( gpSMCurrentMerc );

  HandleSoldierFaceFlash(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y);

  // Render items in guy's hand!
  HandleRenderInvSlots(gpSMCurrentMerc, pfDirty.value);

  if (gfSMDisableForItems && (pfDirty.value) != DIRTYLEVEL0) {
    let pDestBuf: Uint8ClampedArray;
    let uiDestPitchBYTES: UINT32 = 0;
    let ClipRect: SGPRect = createSGPRect();

    ClipRect.iLeft = 87;
    ClipRect.iRight = 536;
    ClipRect.iTop = INV_INTERFACE_START_Y;
    ClipRect.iBottom = 480;
    pDestBuf = LockVideoSurface(FRAME_BUFFER, createPointer(() => uiDestPitchBYTES, (v) => uiDestPitchBYTES = v));
    Blt16BPPBufferHatchRect(pDestBuf, uiDestPitchBYTES, ClipRect);
    UnLockVideoSurface(FRAME_BUFFER);
  }
}

function UpdateStatColor(uiTimer: UINT32, fIncrease: boolean): void {
  if (gpSMCurrentMerc.bLife >= OKLIFE) {
    if ((GetJA2Clock() < CHANGE_STAT_RECENTLY_DURATION + uiTimer) && (uiTimer != 0)) {
      if (fIncrease) {
        SetFontForeground(FONT_LTGREEN);
      } else {
        SetFontForeground(FONT_RED);
      }
    } else {
      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(STATS_TEXT_FONT_COLOR);
    }
  } else {
    SetFontBackground(FONT_MCOLOR_BLACK);
    SetFontForeground(FONT_MCOLOR_DKGRAY);
  }
}

function SMInvMoveCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let uiHandPos: UINT32;

  uiHandPos = MSYS_GetRegionUserData(pRegion, 0);

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (gpSMCurrentMerc.inv[uiHandPos].usItem == NOTHING)
    return;

  if (iReason == MSYS_CALLBACK_REASON_MOVE) {
  } else if (iReason == MSYS_CALLBACK_REASON_GAIN_MOUSE) {
    if (gpItemPointer == null) {
      // Setup a timer....
      guiMouseOverItemTime = GetJA2Clock();
      gfCheckForMouseOverItem = true;
      gbCheckForMouseOverItemPos = uiHandPos;
    }
  }
  if (iReason == MSYS_CALLBACK_REASON_LOST_MOUSE) {
    // gfSM_HandInvDispText[ uiHandPos ] = 1;
    if (gpItemPointer == null) {
      HandleCompatibleAmmoUI(gpSMCurrentMerc, uiHandPos, false);
      gfCheckForMouseOverItem = false;
      fInterfacePanelDirty = DIRTYLEVEL2;
    }
  }
}

function InvPanelButtonClickCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
  }
}

function SMInvMoveCammoCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  } else if (iReason == MSYS_CALLBACK_REASON_GAIN_MOUSE) {
    // Setup a timer....
    guiMouseOverItemTime = GetJA2Clock();
    gfCheckForMouseOverItem = true;
    gbCheckForMouseOverItemPos = NO_SLOT;
  }
  if (iReason == MSYS_CALLBACK_REASON_LOST_MOUSE) {
    // gfSM_HandInvDispText[ uiHandPos ] = 1;
    HandleCompatibleAmmoUI(gpSMCurrentMerc, NO_SLOT, false);
    gfCheckForMouseOverItem = false;
  }
}

function SMInvClickCamoCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  // UINT16 usNewItemIndex;
  let ubSrcID: UINT8;
  let ubDestID: UINT8;
  let fGoodAPs: boolean = false;
  let fGoodAPs__Pointer = createPointer(() => fGoodAPs, (v) => fGoodAPs = v);


  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    // Apply camo ( if we have something in cursor... )
    // If we do not have an item in hand, start moving it
    if (gpItemPointer != null) {
      // ATE: OK, get source, dest guy if different... check for and then charge appropriate APs
      ubSrcID = gpSMCurrentMerc.ubID;
      ubDestID = gpItemPointerSoldier.ubID;

      // if ( ubSrcID == ubDestID )
      {
        // We are doing this ourselve, continue
        if (gpSMCurrentMerc.bLife >= CONSCIOUSNESS) {
          // usNewItemIndex = gpItemPointer->usItem;

          // Try to apply camo....
          if (ApplyCammo(gpSMCurrentMerc, gpItemPointer, fGoodAPs__Pointer)) {
            if (fGoodAPs) {
              // Dirty
              fInterfacePanelDirty = DIRTYLEVEL2;

              // Check if it's the same now!
              if (gpItemPointer.ubNumberOfObjects == 0) {
                gbCompatibleApplyItem = false;
                EndItemPointer();
              }

              // Say OK acknowledge....
              DoMercBattleSound(gpSMCurrentMerc, Enum259.BATTLE_SOUND_COOL1);
            }
          } else if (ApplyCanteen(gpSMCurrentMerc, gpItemPointer, fGoodAPs__Pointer)) {
            // Dirty
            if (fGoodAPs) {
              fInterfacePanelDirty = DIRTYLEVEL2;

              // Check if it's the same now!
              if (gpItemPointer.ubNumberOfObjects == 0) {
                gbCompatibleApplyItem = false;
                EndItemPointer();
              }
            }
          } else if (ApplyElixir(gpSMCurrentMerc, gpItemPointer, fGoodAPs__Pointer)) {
            if (fGoodAPs) {
              // Dirty
              fInterfacePanelDirty = DIRTYLEVEL2;

              // Check if it's the same now!
              if (gpItemPointer.ubNumberOfObjects == 0) {
                gbCompatibleApplyItem = false;
                EndItemPointer();
              }

              // Say OK acknowledge....
              DoMercBattleSound(gpSMCurrentMerc, Enum259.BATTLE_SOUND_COOL1);
            }
          } else if (ApplyDrugs(gpSMCurrentMerc, gpItemPointer)) {
            // Dirty
            fInterfacePanelDirty = DIRTYLEVEL2;

            // Check if it's the same now!
            if (gpItemPointer.ubNumberOfObjects == 0) {
              gbCompatibleApplyItem = false;
              EndItemPointer();
            }

            /*
            // COMMENTED OUT DUE TO POTENTIAL SERIOUS PROBLEMS WITH STRATEGIC EVENT SYSTEM

            if ( gpSMCurrentMerc->ubProfile == LARRY_NORMAL )
            {
                    // Larry's taken something!
                    gpSMCurrentMerc = SwapLarrysProfiles( gpSMCurrentMerc );
            }
            */

            // Say OK acknowledge....
            DoMercBattleSound(gpSMCurrentMerc, Enum259.BATTLE_SOUND_COOL1);
          } else {
            // Send message
            ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_UI_FEEDBACK, TacticalStr[Enum335.CANNOT_DO_INV_STUFF_STR]);
          }
        }
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
  }
}

export function HandleNailsVestFetish(pSoldier: SOLDIERTYPE, uiHandPos: UINT32, usReplaceItem: UINT16): boolean {
  let fRefuse: boolean = false;

  // OK are we nails?
  if (pSoldier.ubProfile == 34) {
    // if this the VEST POS?
    if (uiHandPos == Enum261.VESTPOS) {
      // Are we trying to pick it up?
      if (usReplaceItem == NOTHING) {
        fRefuse = true;
      } else {
        // Do we have nothing or the leather vest or kevlar leather vest?
        if (usReplaceItem == Enum225.LEATHER_JACKET || usReplaceItem == Enum225.LEATHER_JACKET_W_KEVLAR || usReplaceItem == Enum225.LEATHER_JACKET_W_KEVLAR_18 || usReplaceItem == Enum225.LEATHER_JACKET_W_KEVLAR_Y || usReplaceItem == Enum225.COMPOUND18 || usReplaceItem == Enum225.JAR_QUEEN_CREATURE_BLOOD) {
          // This is good....
          fRefuse = false;
        } else {
          fRefuse = true;
        }
      }

      if (fRefuse) {
        // Say quote!
        TacticalCharacterDialogue(pSoldier, 61);
        return true;
      }
    }
  }

  return false;
}

function UIHandleItemPlacement(ubHandPos: UINT8, usOldItemIndex: UINT16, usNewItemIndex: UINT16, fDeductPoints: boolean): boolean {
  if (_KeyDown(CTRL)) {
    CleanUpStack(gpSMCurrentMerc.inv[ubHandPos], gpItemPointer);
    if (gpItemPointer.ubNumberOfObjects == 0) {
      EndItemPointer();
    }
    return true;
  }

  // Try to place here
  if (PlaceObject(gpSMCurrentMerc, ubHandPos, gpItemPointer)) {
    if (fDeductPoints) {
      // Deduct points
      if (gpItemPointerSoldier.bLife >= CONSCIOUSNESS) {
        DeductPoints(gpItemPointerSoldier, 2, 0);
      }
      if (gpSMCurrentMerc.bLife >= CONSCIOUSNESS) {
        DeductPoints(gpSMCurrentMerc, 2, 0);
      }
    }

    HandleTacticalEffectsOfEquipmentChange(gpSMCurrentMerc, ubHandPos, usOldItemIndex, usNewItemIndex);

    // Dirty
    fInterfacePanelDirty = DIRTYLEVEL2;

    // Check if cursor is empty now
    if (gpItemPointer.ubNumberOfObjects == 0) {
      EndItemPointer();
    }

    if (gpItemPointerSoldier != gpSMCurrentMerc) {
      ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, pMessageStrings[Enum333.MSG_ITEM_PASSED_TO_MERC], ShortItemNames[usNewItemIndex], gpSMCurrentMerc.name);
    }

    // UPDATE ITEM POINTER.....
    gpItemPointerSoldier = gpSMCurrentMerc;

    if (gpItemPointer != null) {
      ReevaluateItemHatches(gpSMCurrentMerc, false);
    }

    // Set cursor back to normal mode...
    guiPendingOverrideEvent = Enum207.A_CHANGE_TO_MOVE;

    return true;
  } else {
    return false;
  }
}

/* static */ let SMInvClickCallback__fRightDown: boolean = false;
/* static */ let SMInvClickCallback__fLeftDown: boolean = false;
function SMInvClickCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let uiHandPos: UINT32;
  // Copyies of values
  let usOldItemIndex: UINT16;
  let usNewItemIndex: UINT16;
  let usItemPrevInItemPointer: UINT16;
  let fNewItem: boolean = false;

  uiHandPos = MSYS_GetRegionUserData(pRegion, 0);

  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
    // and this inventory slot is hatched out
    if (ShouldSoldierDisplayHatchOnItem(gpSMCurrentMerc.ubProfile, uiHandPos)) {
      // it means that item is a copy of one in the player's offer area, so we treat it as if the slot was empty (ignore)
      // if the cursor has an item in it, we still ignore the click, because handling swaps in this situation would be
      // ugly, we'd have to the the swap, then make the bOwnerSlot of the item just picked up a -1 in its offer area spot.
      return;
    }
  }

  // if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
  //{
  //	fLeftDown = TRUE;
  //}
  // else if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP && fLeftDown )
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    SMInvClickCallback__fLeftDown = false;

    // If we do not have an item in hand, start moving it
    if (gpItemPointer == null) {
      // Return if empty
      if (gpSMCurrentMerc.inv[uiHandPos].usItem == NOTHING)
        return;

      if (gpSMCurrentMerc.ubID != gusSelectedSoldier) {
        SelectSoldier(gpSMCurrentMerc.ubID, false, false);
      }

      // OK, check if this is Nails, and we're in the vest position , don't allow it to come off....
      if (HandleNailsVestFetish(gpSMCurrentMerc, uiHandPos, NOTHING)) {
        return;
      }

      if (_KeyDown(CTRL)) {
        CleanUpStack(gpSMCurrentMerc.inv[uiHandPos], null);
        return;
      }

      // Turn off new item glow!
      gpSMCurrentMerc.bNewItemCount[uiHandPos] = 0;

      usOldItemIndex = gpSMCurrentMerc.inv[uiHandPos].usItem;

      // move item into the mouse cursor
      BeginItemPointer(gpSMCurrentMerc, uiHandPos);

      // if we are in the shopkeeper interface
      if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
        // pick up item from regular inventory slot into cursor OR try to sell it ( unless CTRL is held down )
        BeginSkiItemPointer(Enum252.PLAYERS_INVENTORY, uiHandPos, !gfKeyState[CTRL]);
      }

      HandleTacticalEffectsOfEquipmentChange(gpSMCurrentMerc, uiHandPos, usOldItemIndex, NOTHING);

      // HandleCompatibleAmmoUI( gpSMCurrentMerc, (INT8)uiHandPos, FALSE );
    } else // item in cursor
    {
      let ubSrcID: UINT8;
      let ubDestID: UINT8;
      let fOKToGo: boolean = false;
      let fDeductPoints: boolean = false;

      // ATE: OK, get source, dest guy if different... check for and then charge appropriate APs
      ubSrcID = gpSMCurrentMerc.ubID;
      ubDestID = gpItemPointerSoldier.ubID;

      if (ubSrcID == ubDestID) {
        // We are doing this ourselve, continue
        fOKToGo = true;
      } else {
        // These guys are different....
        fDeductPoints = true;

        // First check points for src guy
        if (gpItemPointerSoldier.bLife >= CONSCIOUSNESS) {
          if (EnoughPoints(gpItemPointerSoldier, 3, 0, true)) {
            fOKToGo = true;
          }
        } else {
          fOKToGo = true;
        }

        // Should we go on?
        if (fOKToGo) {
          if (gpSMCurrentMerc.bLife >= CONSCIOUSNESS) {
            if (EnoughPoints(gpSMCurrentMerc, 3, 0, true)) {
              fOKToGo = true;
            } else {
              fOKToGo = false;
            }
          }
        }
      }

      if (fOKToGo) {
        // OK, check if this is Nails, and we're in the vest position , don't allow it to come off....
        if (HandleNailsVestFetish(gpSMCurrentMerc, uiHandPos, gpItemPointer.usItem)) {
          return;
        }

        usOldItemIndex = gpSMCurrentMerc.inv[uiHandPos].usItem;
        usNewItemIndex = gpItemPointer.usItem;

        if (uiHandPos == Enum261.HANDPOS || uiHandPos == Enum261.SECONDHANDPOS || uiHandPos == Enum261.HELMETPOS || uiHandPos == Enum261.VESTPOS || uiHandPos == Enum261.LEGPOS) {
          // if ( ValidAttachmentClass( usNewItemIndex, usOldItemIndex ) )
          if (ValidAttachment(usNewItemIndex, usOldItemIndex)) {
            // it's an attempt to attach; bring up the inventory panel
            if (!InItemDescriptionBox()) {
              InitItemDescriptionBox(gpSMCurrentMerc, uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0);
            }
            return;
          } else if (ValidMerge(usNewItemIndex, usOldItemIndex)) {
            // bring up merge requestor
            gubHandPos = uiHandPos;
            gusOldItemIndex = usOldItemIndex;
            gusNewItemIndex = usNewItemIndex;
            gfDeductPoints = fDeductPoints;

            if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
              // the only way to merge items is to pick them up.  In SKI when you pick up an item, the cursor is
              // locked in a region, free it up.
              FreeMouseCursor();

              DoMessageBox(Enum24.MSG_BOX_BASIC_STYLE, Message[Enum334.STR_MERGE_ITEMS], Enum26.SHOPKEEPER_SCREEN, MSG_BOX_FLAG_YESNO, MergeMessageBoxCallBack, null);
            } else
              DoMessageBox(Enum24.MSG_BOX_BASIC_STYLE, Message[Enum334.STR_MERGE_ITEMS], Enum26.GAME_SCREEN, MSG_BOX_FLAG_YESNO, MergeMessageBoxCallBack, null);
            return;
          }
          // else handle normally
        }

        // remember the item type currently in the item pointer
        usItemPrevInItemPointer = gpItemPointer.usItem;

        if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
          // If it's just been purchased or repaired, mark it as a "new item"
          fNewItem = Boolean(gMoveingItem.uiFlags & (ARMS_INV_JUST_PURCHASED | ARMS_INV_ITEM_REPAIRED));
        }

        // try to place the item in the cursor into this inventory slot
        if (UIHandleItemPlacement(uiHandPos, usOldItemIndex, usNewItemIndex, fDeductPoints)) {
          // it worked!  if we're in the SKI...
          if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
            SetNewItem(gpSMCurrentMerc, uiHandPos, fNewItem);

            // and the cursor is now empty
            if (gpItemPointer == null) {
              // clean up
              resetInventoryInSlot(gMoveingItem);
              SetSkiCursor(Enum317.CURSOR_NORMAL);
            } else {
              // if we're holding something else in the pointer now
              if (usItemPrevInItemPointer != gpItemPointer.usItem) {
                // pick up item swapped out of inventory slot into cursor (don't try to sell)
                BeginSkiItemPointer(Enum252.PLAYERS_INVENTORY, -1, false);
              } else {
                // otherwise, leave the cursor as is, means more items were picked up at once than can be placed in this slot
                // we deal with this by leaving the remainder in the cursor, to be put down elsewhere using subsequent clicks
              }
            }
          }

          // Setup a timer....
          // guiMouseOverItemTime = GetJA2Clock( );
          // gfCheckForMouseOverItem = TRUE;
          // gbCheckForMouseOverItemPos = (INT8)uiHandPos;
        }

        /*
        // Try to place here
        if ( PlaceObject( gpSMCurrentMerc, (UINT8)uiHandPos, gpItemPointer ) )
        {

                if ( fDeductPoints )
                {
                        // Deduct points
                        if ( gpItemPointerSoldier->bLife >= CONSCIOUSNESS )
                        {
                                DeductPoints( gpItemPointerSoldier,  2, 0 );
                        }
                        if ( gpSMCurrentMerc->bLife >= CONSCIOUSNESS )
                        {
                                DeductPoints( gpSMCurrentMerc,  2, 0 );
                        }
                }

                HandleTacticalEffectsOfEquipmentChange( gpSMCurrentMerc, uiHandPos, usOldItemIndex, usNewItemIndex );

                // Dirty
                fInterfacePanelDirty = DIRTYLEVEL2;

                // Check if it's the same now!
                if ( gpItemPointer->ubNumberOfObjects == 0 )
                {
                        EndItemPointer( );
                }

                // Setup a timer....
                guiMouseOverItemTime = GetJA2Clock( );
                gfCheckForMouseOverItem = TRUE;
                gbCheckForMouseOverItemPos = (INT8)uiHandPos;

        }
        */
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    SMInvClickCallback__fRightDown = true;
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_UP && SMInvClickCallback__fRightDown) {
    SMInvClickCallback__fRightDown = false;

    // Return if empty
    if (gpSMCurrentMerc.inv[uiHandPos].usItem == NOTHING)
      return;

    // CJC: OK, get source, dest guy if different, don't allow panels to be brought up
    /*
    if ( gpItemPointer && gpSMCurrentMerc->ubID != gpItemPointerSoldier->ubID )
    {
            return;
    }
    */

    // Turn off new item glow!
    gpSMCurrentMerc.bNewItemCount[uiHandPos] = 0;

    // Some global stuff here - for esc, etc
    // Check for # of slots in item
    if ((gpSMCurrentMerc.inv[uiHandPos].ubNumberOfObjects > 1 && ItemSlotLimit(gpSMCurrentMerc.inv[uiHandPos].usItem, uiHandPos) > 0) && (guiCurrentScreen != Enum26.MAP_SCREEN)) {
      if (!InItemStackPopup()) {
        // InitItemStackPopup( gpSMCurrentMerc, (UINT8)uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, SM_ITEMDESC_WIDTH, SM_ITEMDESC_HEIGHT );
        InitItemStackPopup(gpSMCurrentMerc, uiHandPos, 216, INV_INTERFACE_START_Y, 314, (480 - INV_INTERFACE_START_Y));
      }
    } else {
      if (!InItemDescriptionBox()) {
        InitItemDescriptionBox(gpSMCurrentMerc, uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0);
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    SMInvClickCallback__fRightDown = false;
    SMInvClickCallback__fLeftDown = false;
  }
}

function MergeMessageBoxCallBack(ubExitValue: UINT8): void {
  if (ubExitValue == MSG_BOX_RETURN_YES) {
    AttachObject(gpItemPointerSoldier, gpSMCurrentMerc.inv[gubHandPos], gpItemPointer);

    // re-evaluate repairs
    gfReEvaluateEveryonesNothingToDo = true;

    if (gpItemPointer.usItem == NOTHING) {
      // merge item consumed
      EndItemPointer();
      fInterfacePanelDirty = DIRTYLEVEL2;
    }
  } else {
    UIHandleItemPlacement(gubHandPos, gusOldItemIndex, gusNewItemIndex, gfDeductPoints);
  }
}

function HandleMouseOverSoldierFaceForContMove(pSoldier: SOLDIERTYPE, fOn: boolean): void {
  let pFace: FACETYPE;
  let sGridNo: INT16;

  if (pSoldier == null) {
    return;
  }

  if (fOn) {
    // Check if we are waiting to continue move...
    if (CheckForMercContMove(pSoldier)) {
      // Display 'cont' on face....
      // Get face
      pFace = gFacesData[pSoldier.iFaceIndex];

      pFace.fDisplayTextOver = FACE_DRAW_TEXT_OVER;
      pFace.zDisplayText = TacticalStr[Enum335.CONTINUE_OVER_FACE_STR];

      sGridNo = pSoldier.sFinalDestination;

      if (pSoldier.bGoodContPath) {
        sGridNo = pSoldier.sContPathLocation;
      }

      // While our mouse is here, draw a path!
      PlotPath(pSoldier, sGridNo, NO_COPYROUTE, PLOT, TEMPORARY, pSoldier.usUIMovementMode, NOT_STEALTH, FORWARD, pSoldier.bActionPoints);
    }
  } else {
    // Remove 'cont' on face....
    // Get face
    pFace = gFacesData[pSoldier.iFaceIndex];

    pFace.fDisplayTextOver = FACE_ERASE_TEXT_OVER;

    // Erase path!
    ErasePath(true);
  }

  fInterfacePanelDirty = DIRTYLEVEL2;
}

function SelectedMercButtonMoveCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  if (gpSMCurrentMerc == null) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_MOVE) {
    HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, true);
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, false);
  }
}

function SelectedMercButtonCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let pVehicle: SOLDIERTYPE;

  if (gpSMCurrentMerc == null) {
    return;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    // ATE: Don't if this guy can't....
    if (!gfSMDisableForItems) {
      if (gpSMCurrentMerc.uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
        pVehicle = GetSoldierStructureForVehicle(gpSMCurrentMerc.iVehicleId);

        HandleLocateSelectMerc(pVehicle.ubID, 0);
      } else {
        if (CheckForMercContMove(gpSMCurrentMerc)) {
          // Continue
          ContinueMercMovement(gpSMCurrentMerc);
          ErasePath(true);
        } else {
          HandleLocateSelectMerc(gpSMCurrentMerc.ubID, 0);
        }
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    // ATE: Cannot get out by right clicking...
    // if ( gpItemPointer == NULL )
    {
      // if ( !gfSMDisableForItems || ( gfSMDisableForItems && gpItemPointer == NULL ) )
      {
        // Delete desc
        if (InItemDescriptionBox()) {
          DeleteItemDescriptionBox();
        }

        gfSwitchPanel = true;
        gbNewPanel = Enum215.TEAM_PANEL;
      }
    }
  }
}

function SelectedMercEnemyIndicatorCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  if (gpSMCurrentMerc == null) {
    return;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    // ATE: Don't if this guy can't....
    if (!gfSMDisableForItems) {
      if (gpSMCurrentMerc.uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
      } else {
        if (gpSMCurrentMerc.bOppCnt > 0) {
          CycleVisibleEnemies(gpSMCurrentMerc);
        } else {
          SelectedMercButtonCallback(pRegion, iReason);
        }
      }
    }
  }
}

function BtnStanceUpCallback(btn: GUI_BUTTON, reason: INT32): void {
  let bNewStance: INT8;

  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    bNewStance = gAnimControl[gpSMCurrentMerc.usAnimState].ubEndHeight;

    if (bNewStance == ANIM_CROUCH) {
      bNewStance = ANIM_STAND;
    } else if (bNewStance == ANIM_PRONE) {
      bNewStance = ANIM_CROUCH;
    }

    UIHandleSoldierStanceChange(gpSMCurrentMerc.ubID, bNewStance);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnUpdownCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    // gsInterfaceLevel = gpSMCurrentMerc->bUIInterfaceLevel;

    // Change interface level via HandleUI handler
    UIHandleChangeLevel(null);

    // Remember soldier's new value
    gpSMCurrentMerc.bUIInterfaceLevel = gsInterfaceLevel;
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnClimbCallback(btn: GUI_BUTTON, reason: INT32): void {
  let fNearHeigherLevel: boolean;
  let fNearLowerLevel: boolean;
  let bDirection: INT8 = 0;

  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    ({ fNearLowerLevel, fNearHeigherLevel } = GetMercClimbDirection(gpSMCurrentMerc.ubID));

    if (fNearLowerLevel) {
      BeginSoldierClimbDownRoof(gpSMCurrentMerc);
    }
    if (fNearHeigherLevel) {
      BeginSoldierClimbUpRoof(gpSMCurrentMerc);
    }

    if (FindFenceJumpDirection(gpSMCurrentMerc, gpSMCurrentMerc.sGridNo, gpSMCurrentMerc.bDirection, createPointer(() => bDirection, (v) => bDirection = v))) {
      BeginSoldierClimbFence(gpSMCurrentMerc);
    }
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnStanceDownCallback(btn: GUI_BUTTON, reason: INT32): void {
  let bNewStance: INT8;

  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    bNewStance = gAnimControl[gpSMCurrentMerc.usAnimState].ubEndHeight;

    if (bNewStance == ANIM_STAND) {
      bNewStance = ANIM_CROUCH;
    } else if (bNewStance == ANIM_CROUCH) {
      bNewStance = ANIM_PRONE;
    }

    UIHandleSoldierStanceChange(gpSMCurrentMerc.ubID, bNewStance);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnStealthModeCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    gpSMCurrentMerc.bStealthMode = !gpSMCurrentMerc.bStealthMode;
    gfUIStanceDifferent = true;
    gfPlotNewMovement = true;
    fInterfacePanelDirty = DIRTYLEVEL2;
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnHandCursorCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    ToggleHandCursorMode(guiCurrentEvent__Pointer);
  }
}

function BtnTalkCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    ToggleTalkCursorMode(guiCurrentEvent__Pointer);
  }
}

function BtnMuteCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    if (gpSMCurrentMerc.uiStatusFlags & SOLDIER_MUTE) {
      ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, TacticalStr[Enum335.MUTE_OFF_STR], gpSMCurrentMerc.name);
      gpSMCurrentMerc.uiStatusFlags &= (~SOLDIER_MUTE);
    } else {
      ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, TacticalStr[Enum335.MUTE_ON_STR], gpSMCurrentMerc.name);
      gpSMCurrentMerc.uiStatusFlags |= (SOLDIER_MUTE);
    }
  }
}

function BtnPrevMercCallback(btn: GUI_BUTTON, reason: INT32): void {
  let sID: INT16;

  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    sID = FindPrevActiveAndAliveMerc(gpSMCurrentMerc, true, true);

    gubSelectSMPanelToMerc = sID;

    if (!gfInItemPickupMenu) {
      // if we are in the shop keeper interface
      if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
        LocateSoldier(sID, DONTSETLOCATOR);
        // refresh background for player slots (in case item values change due to Flo's discount)
        gubSkiDirtyLevel = Enum253.SKI_DIRTY_LEVEL2;
      } else
        LocateSoldier(sID, SETLOCATOR);
    }

    // if the user is in the shop keeper interface and is in the item desc
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
      if (InItemDescriptionBox()) {
        DeleteItemDescriptionBox();
      }
    }
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnNextMercCallback(btn: GUI_BUTTON, reason: INT32): void {
  let sID: INT16;

  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    sID = FindNextActiveAndAliveMerc(gpSMCurrentMerc, true, true);

    // Give him the panel!
    gubSelectSMPanelToMerc = sID;

    if (!gfInItemPickupMenu) {
      // if we are in the shop keeper interface
      if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
        LocateSoldier(sID, DONTSETLOCATOR);
        // refresh background for player slots (in case item values change due to Flo's discount)
        gubSkiDirtyLevel = Enum253.SKI_DIRTY_LEVEL2;
      } else
        LocateSoldier(sID, SETLOCATOR);
    }

    // if the user is in the shop keeper interface and is in the item desc
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
      if (InItemDescriptionBox()) {
        DeleteItemDescriptionBox();
      }
    }
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnOptionsCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    guiPreviousOptionScreen = guiCurrentScreen;
    LeaveTacticalScreen(Enum26.OPTIONS_SCREEN);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnSMDoneCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    gfBeginEndTurn = true;
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnMapScreenCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    // Enter mapscreen...
    // gfEnteringMapScreen = 1;
    GoToMapScreenFromTactical();
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

/*
uiTempVObject[0] = LoadButtonImage( "Interface\\InventoryButtons.sti", -1, 7, -1, -1, -1 );
uiTempVObject[1] = UseLoadedButtonImage( uiTempVObject[0], -1, 17, -1, -1, -1 );
uiTempVObject[2] = UseLoadedButtonImage( uiTempVObject[0], -1, 26, -1, -1, -1 );
iButtonID = QuickCreateButton( uiTempVObject[0], 0, 0, BUTTON_NO_TOGGLE, MSYS_PRIORITY_HIGH, MSYS_NO_CALLBACK, CycleCallback );

void CycleCallback( GUI_BUTTON *btn, INT32 reason )
{
        static INT32 buttonValue = 0;
        if( reason & MSYS_CALLBACK_REASON_LBUTTON_UP )
        {
                buttonValue += buttonValue < 2 ? 1 : -2;
                btn->ImageNum = uiTempVObject[ buttonValue ];
                btn->uiFlags |= BUTTON_DIRTY;
        }
}
*/

function BtnBurstModeCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (!(btn.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    ChangeWeaponMode(gpSMCurrentMerc);
    //		btn->ImageNum = iBurstButtonImages[ gpSMCurrentMerc->bWeaponMode ];
    //		btn->uiFlags |= BUTTON_DIRTY;
  }
}

function BtnLookCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    ToggleLookCursorMode(null);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnPositionShowCallback(btn: GUI_BUTTON, reason: INT32): void {
}

// TEAM PANEL!!!!!!!!!!!!!!
/* static */ let InitializeTEAMPanel__fFirstTime: boolean = true;
export function InitializeTEAMPanel(): boolean {
  let vs_desc: VSURFACE_DESC = createVSurfaceDesc();
  let VObjectDesc: VOBJECT_DESC = createVObjectDesc();
  let cnt: UINT32;
  let posIndex: UINT32;

  // INit viewport region
  // Set global mouse regions
  // Define region for viewport
  MSYS_DefineRegion(gViewportRegion, 0, 0, gsVIEWPORT_END_X, gsVIEWPORT_END_Y, MSYS_PRIORITY_NORMAL, VIDEO_NO_CURSOR, MSYS_NO_CALLBACK, MSYS_NO_CALLBACK);
  // Add region
  MSYS_AddRegion(gViewportRegion);

  // Load interface panels
  vs_desc.fCreateFlags = VSURFACE_CREATE_FROMFILE | VSURFACE_SYSTEM_MEM_USAGE;

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = FilenameForBPP("INTERFACE\\bottom_bar.sti");
  if (!(guiTEAMPanel = AddVideoObject(VObjectDesc))) {
    return false;
  }

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = FilenameForBPP("INTERFACE\\gold_front.sti");
  if (!(guiTEAMObjects = AddVideoObject(VObjectDesc))) {
    return false;
  }

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  VObjectDesc.ImageFile = FilenameForBPP("INTERFACE\\Bars.sti");
  if (!(guiBrownBackgroundForTeamPanel = AddVideoObject(VObjectDesc))) {
    return false;
  }

  // Clear inv display stuff
  for (let i = 0; i < gfTEAM_HandInvDispText.length; i++) {
    gfTEAM_HandInvDispText[i].fill(0);
  }

  // Create buttons
  if (!CreateTEAMPanelButtons()) {
    return false;
  }

  // Set viewports
  // Define region for panel
  MSYS_DefineRegion(gTEAM_PanelRegion, 0, gsVIEWPORT_END_Y, 640, 480, MSYS_PRIORITY_NORMAL, Enum317.CURSOR_NORMAL, MSYS_NO_CALLBACK, MSYS_NO_CALLBACK);
  // Add region
  MSYS_AddRegion(gTEAM_PanelRegion);

  for (posIndex = 0, cnt = 0; cnt < 6; cnt++, posIndex += 2) {
    MSYS_DefineRegion(gTEAM_FaceRegions[cnt], sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], (sTEAMFacesXY[posIndex] + TM_FACE_WIDTH), (sTEAMFacesXY[posIndex + 1] + TM_FACE_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MercFacePanelMoveCallback, MercFacePanelCallback);
    // Add region
    MSYS_AddRegion(gTEAM_FaceRegions[cnt]);
    MSYS_SetRegionUserData(gTEAM_FaceRegions[cnt], 0, cnt);

    MSYS_DefineRegion(gTEAM_EnemyIndicator[cnt], (sTEAMFacesXY[posIndex] + 1), (sTEAMFacesXY[posIndex + 1] + 1), (sTEAMFacesXY[posIndex] + INDICATOR_BOX_WIDTH), (sTEAMFacesXY[posIndex + 1] + INDICATOR_BOX_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, EnemyIndicatorClickCallback);
    // Add region
    MSYS_AddRegion(gTEAM_EnemyIndicator[cnt]);
    MSYS_SetRegionUserData(gTEAM_EnemyIndicator[cnt], 0, cnt);

    if (IsMouseInRegion(gTEAM_FaceRegions[cnt])) {
      if (gTeamPanel[cnt].ubID != NOBODY) {
        HandleMouseOverSoldierFaceForContMove(MercPtrs[gTeamPanel[cnt].ubID], true);
      }
    }

    MSYS_DefineRegion(gTEAM_BarsRegions[cnt], sTEAMBarsXY[posIndex], sTEAMBarsXY[posIndex + 1], (sTEAMBarsXY[posIndex] + TM_BARS_REGION_WIDTH), (sTEAMBarsXY[posIndex + 1] + TM_BARS_REGION_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, MercFacePanelCallback);
    // Add region
    MSYS_AddRegion(gTEAM_BarsRegions[cnt]);
    MSYS_SetRegionUserData(gTEAM_BarsRegions[cnt], 0, cnt);

    MSYS_DefineRegion(gTEAM_LeftBarsRegions[cnt], (sTEAMFacesXY[posIndex] - 8), sTEAMFacesXY[posIndex + 1], (sTEAMFacesXY[posIndex]), (sTEAMFacesXY[posIndex + 1] + TM_BARS_REGION_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, MercFacePanelCallback);
    // Add region
    MSYS_AddRegion(gTEAM_LeftBarsRegions[cnt]);
    MSYS_SetRegionUserData(gTEAM_LeftBarsRegions[cnt], 0, cnt);

    MSYS_DefineRegion(gTEAM_FirstHandInv[cnt], sTEAMHandInvXY[posIndex], sTEAMHandInvXY[posIndex + 1], (sTEAMHandInvXY[posIndex] + TM_INV_WIDTH), (sTEAMHandInvXY[posIndex + 1] + TM_INV_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, TMClickFirstHandInvCallback);
    // Add region
    MSYS_AddRegion(gTEAM_FirstHandInv[cnt]);

    // Add user data
    MSYS_SetRegionUserData(gTEAM_FirstHandInv[cnt], 0, cnt);

    MSYS_DefineRegion(gTEAM_SecondHandInv[cnt], sTEAMHandInvXY[posIndex], (sTEAMHandInvXY[posIndex + 1] + 24), (sTEAMHandInvXY[posIndex] + TM_INV_WIDTH), (sTEAMHandInvXY[posIndex + 1] + TM_INV_HEIGHT + 24), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, TMClickSecondHandInvCallback);
    // Add region
    MSYS_AddRegion(gTEAM_SecondHandInv[cnt]);

    // Add user data
    MSYS_SetRegionUserData(gTEAM_SecondHandInv[cnt], 0, cnt);
  }

  // DEfine region for selected guy panel
  // MSYS_DefineRegion( &gSM_SELMERCPanalRegion, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, SM_SELMERC_FACE_X + SM_SELMERC_FACE_WIDTH, SM_SELMERC_FACE_Y + SM_SELMERC_FACE_HEIGHT, MSYS_PRIORITY_NORMAL,
  //					 CURSOR_NORMAL, MSYS_NO_CALLBACK, SelectedMercButtonCallback );
  // Add region
  // MSYS_AddRegion( &gSM_SELMERCPanalRegion );

  return true;
}

export function ShutdownTEAMPanel(): boolean {
  let cnt: UINT32;

  // All buttons and regions and video objects and video surfaces will be deleted at shutddown of SGM
  // We may want to delete them at the interm as well, to free up room for other panels
  // Delete video objects!
  DeleteVideoObjectFromIndex(guiTEAMPanel);
  DeleteVideoObjectFromIndex(guiTEAMObjects);
  DeleteVideoObjectFromIndex(guiBrownBackgroundForTeamPanel);

  MSYS_RemoveRegion(gTEAM_PanelRegion);

  // Remove viewport
  MSYS_RemoveRegion(gViewportRegion);

  for (cnt = 0; cnt < 6; cnt++) {
    MSYS_RemoveRegion(gTEAM_EnemyIndicator[cnt]);
    MSYS_RemoveRegion(gTEAM_FaceRegions[cnt]);
    MSYS_RemoveRegion(gTEAM_BarsRegions[cnt]);
    MSYS_RemoveRegion(gTEAM_LeftBarsRegions[cnt]);
    MSYS_RemoveRegion(gTEAM_FirstHandInv[cnt]);
    MSYS_RemoveRegion(gTEAM_SecondHandInv[cnt]);

    if (gTeamPanel[cnt].ubID != NOBODY) {
      HandleMouseOverSoldierFaceForContMove(MercPtrs[gTeamPanel[cnt].ubID], false);
    }
  }

  // Remove buttons
  RemoveTEAMPanelButtons();

  // turn off the display of the squad list
  if (fRenderRadarScreen == false) {
    // start rendering radar region again,
    fRenderRadarScreen = true;

    // remove squad panel
    // CreateDestroyMouseRegionsForSquadList( );
  }
  return true;
}

/* static */ let RenderTEAMPanel__pStr: string /* INT16[200] */;
/* static */ let RenderTEAMPanel__pMoraleStr: string /* INT16[20] */;
export function RenderTEAMPanel(fDirty: UINT8 /* boolean */): void {
  let sFontX: INT16;
  let sFontY: INT16;
  let cnt: UINT32;
  let posIndex: UINT32;
  let pSoldier: SOLDIERTYPE;

  if (fDirty == DIRTYLEVEL2) {
    MarkAButtonDirty(iTEAMPanelButtons[Enum221.TEAM_DONE_BUTTON]);
    MarkAButtonDirty(iTEAMPanelButtons[Enum221.TEAM_MAP_SCREEN_BUTTON]);
    MarkAButtonDirty(iTEAMPanelButtons[Enum221.CHANGE_SQUAD_BUTTON]);

    // Blit video surface
    // if(gbPixelDepth==16)
    //{
    BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMPanel, 0, INTERFACE_START_X, INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, null);
    //}
    RestoreExternBackgroundRect(INTERFACE_START_X, INTERFACE_START_Y, (640 - INTERFACE_START_X), (480 - INTERFACE_START_Y));

    // LOOP THROUGH ALL MERCS ON TEAM PANEL
    for (cnt = 0, posIndex = 0; cnt < NUM_TEAM_SLOTS; cnt++, posIndex += 2) {
      // GET SOLDIER
      if (!gTeamPanel[cnt].fOccupied) {
        // BLIT CLOSE PANEL
        BltVideoObjectFromIndex(guiSAVEBUFFER, guiCLOSE, 5, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, null);
        RestoreExternBackgroundRect(sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], TM_FACE_WIDTH, TM_FACE_HEIGHT);

        // BLIT AP CLOSE PANEL
        // BltVideoObjectFromIndex( FRAME_BUFFER, guiTEAMObjects, 3, sTEAMAPPanelXY[ posIndex ], sTEAMAPPanelXY[ posIndex + 1 ], VO_BLT_SRCTRANSPARENCY, NULL );
        // RestoreExternBackgroundRect( (INT16)(sTEAMAPPanelXY[ posIndex ]), (INT16)(sTEAMAPPanelXY[ posIndex + 1 ]), TM_APPANEL_WIDTH, TM_APPANEL_HEIGHT );
        // InvalidateRegion( (INT16)(sTEAMAPPanelXY[ posIndex ]), (INT16)(sTEAMAPPanelXY[ posIndex + 1 ]), (INT16)(sTEAMAPPanelXY[ posIndex ] + TM_APPANEL_WIDTH), (INT16)(sTEAMAPPanelXY[ posIndex + 1 ] + TM_APPANEL_HEIGHT ) );

        if (gTacticalStatus.ubCurrentTeam != OUR_TEAM || INTERRUPT_QUEUED()) {
          // Hatch out...
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, null);
          RestoreExternBackgroundRect(sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT);
        }
      } else {
        pSoldier = MercPtrs[gTeamPanel[cnt].ubID];

        if (pSoldier.uiStatusFlags & (SOLDIER_DRIVER)) {
          // Get soldier pointer for vehicle.....
          let pVehicle: SOLDIERTYPE;

          pVehicle = GetSoldierStructureForVehicle(pSoldier.iVehicleId);

          // OK, for each item, set dirty text if applicable!
          RenderTEAMPanel__pStr = swprintf(TacticalStr[Enum335.DRIVER_POPUPTEXT], pVehicle.bLife, pVehicle.bLifeMax, pVehicle.bBreath, pVehicle.bBreathMax);
          SetRegionFastHelpText(gTEAM_FirstHandInv[cnt], RenderTEAMPanel__pStr);
        }
        // Add text for first hand popup
        else {
          RenderTEAMPanel__pStr = GetHelpTextForItem(pSoldier.inv[Enum261.HANDPOS], pSoldier);

          // OK, for each item, set dirty text if applicable!
          SetRegionFastHelpText(gTEAM_FirstHandInv[cnt], RenderTEAMPanel__pStr);
        }

        // Add text for seonc hand popup
        if (pSoldier.uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
          // OK, for each item, set dirty text if applicable!
          SetRegionFastHelpText(gTEAM_SecondHandInv[cnt], TacticalStr[Enum335.EXIT_VEHICLE_POPUPTEXT]);
        } else {
          RenderTEAMPanel__pStr = GetHelpTextForItem(pSoldier.inv[Enum261.SECONDHANDPOS], pSoldier);

          // OK, for each item, set dirty text if applicable!
          SetRegionFastHelpText(gTEAM_SecondHandInv[cnt], RenderTEAMPanel__pStr);
        }

        // Render Selected guy if selected
        if (gusSelectedSoldier == pSoldier.ubID && gTacticalStatus.ubCurrentTeam == OUR_TEAM && OK_INTERRUPT_MERC(pSoldier)) {
          // if(gbPixelDepth==16)
          //{
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMObjects, 0, sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, null);
          RestoreExternBackgroundRect(sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT);

          // Render faceplate
          // BltVideoObjectFromIndex( guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X, sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y, VO_BLT_SRCTRANSPARENCY, NULL );
          // RestoreExternBackgroundRect( (INT16)(sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X), (INT16)(sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y ), TM_FACEPLATE_WIDTH, TM_FACEPLATE_HEIGHT );
          //}
        } else if (gTacticalStatus.ubCurrentTeam != OUR_TEAM || !OK_INTERRUPT_MERC(pSoldier)) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, null);
          RestoreExternBackgroundRect(sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT);
          // Render non-selection
          // BltVideoObjectFromIndex( guiSAVEBUFFER, guiTEAMObjects, 4, sTEAMFaceHighlXY[ posIndex ], sTEAMFaceHighlXY[ posIndex + 1 ], VO_BLT_SRCTRANSPARENCY, NULL );
          // RestoreExternBackgroundRect( sTEAMFaceHighlXY[ posIndex ], sTEAMFaceHighlXY[ posIndex + 1 ], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT );

          // Render faceplate
          // BltVideoObjectFromIndex( guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X, sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y, VO_BLT_SRCTRANSPARENCY, NULL );
          // RestoreExternBackgroundRect( (INT16)(sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X), (INT16)(sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y ), TM_FACEPLATE_WIDTH, TM_FACEPLATE_HEIGHT );
        }

        CheckForFacePanelStartAnims(pSoldier, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1]);

        RenderSoldierFace(pSoldier, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], true);

        // Restore AP/LIFE POSIITONS

        // Render name!
        SetFont(BLOCKFONT2());

        if (pSoldier.bStealthMode) {
          SetFontBackground(FONT_MCOLOR_BLACK);
          SetFontForeground(FONT_MCOLOR_LTYELLOW);
        } else {
          SetFontBackground(FONT_MCOLOR_BLACK);
          SetFontForeground(FONT_MCOLOR_LTGRAY);
        }

        // RENDER ON SAVE BUFFER!
        SetFontDestBuffer(guiSAVEBUFFER, 0, 0, 640, 480, false);
        ({ sX: sFontX, sY: sFontY } = VarFindFontCenterCoordinates((sTEAMNamesXY[posIndex] + 2), (sTEAMNamesXY[posIndex + 1]), TM_NAME_WIDTH, TM_NAME_HEIGHT, BLOCKFONT2(), "%s", pSoldier.name));
        mprintf(sFontX, sFontY, "%s", pSoldier.name);
        gprintfRestore(sFontX, sFontY, "%s", pSoldier.name);
        // reset to frame buffer!
        SetFontDestBuffer(FRAME_BUFFER, 0, 0, 640, 480, false);
      }
    }

    RenderTownIDString();
  }

  // Loop through all mercs and make go
  for (cnt = 0, posIndex = 0; cnt < NUM_TEAM_SLOTS; cnt++, posIndex += 2) {
    // GET SOLDIER
    if (gTeamPanel[cnt].fOccupied) {
      pSoldier = MercPtrs[gTeamPanel[cnt].ubID];

      // Update animations....
      if (pSoldier.fClosePanel || pSoldier.fClosePanelToDie) {
        pSoldier.sPanelFaceX = gFacesData[pSoldier.iFaceIndex].usFaceX;
        pSoldier.sPanelFaceY = gFacesData[pSoldier.iFaceIndex].usFaceY;
      }

      if (fDirty != DIRTYLEVEL0) {
        // UPdate stats!
        if (fDirty == DIRTYLEVEL2) {
          if (pSoldier.bLife != 0) {
            if (pSoldier.uiStatusFlags & SOLDIER_VEHICLE) {
              RenderTEAMPanel__pStr = swprintf(TacticalStr[Enum335.VEHICLE_VITAL_STATS_POPUPTEXT], pSoldier.bLife, pSoldier.bLifeMax, pSoldier.bBreath, pSoldier.bBreathMax);
              SetRegionFastHelpText(gTEAM_BarsRegions[cnt], RenderTEAMPanel__pStr);
            } else if (pSoldier.uiStatusFlags & SOLDIER_ROBOT) {
              RenderTEAMPanel__pStr = swprintf(gzLateLocalizedString[16], pSoldier.bLife, pSoldier.bLifeMax);
              SetRegionFastHelpText(gTEAM_BarsRegions[cnt], RenderTEAMPanel__pStr);
            } else {
              RenderTEAMPanel__pMoraleStr = GetMoraleString(pSoldier);
              RenderTEAMPanel__pStr = swprintf(TacticalStr[Enum335.MERC_VITAL_STATS_POPUPTEXT], pSoldier.bLife, pSoldier.bLifeMax, pSoldier.bBreath, pSoldier.bBreathMax, RenderTEAMPanel__pMoraleStr);
              SetRegionFastHelpText(gTEAM_BarsRegions[cnt], RenderTEAMPanel__pStr);
            }
          } else {
            SetRegionFastHelpText(gTEAM_BarsRegions[cnt], "");
          }
        }

        if (!(pSoldier.uiStatusFlags & SOLDIER_DEAD)) {
          DrawLifeUIBarEx(pSoldier, sTEAMLifeXY[posIndex], sTEAMLifeXY[posIndex + 1], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, true, FRAME_BUFFER);

          if (!(pSoldier.uiStatusFlags & SOLDIER_ROBOT)) {
            DrawBreathUIBarEx(pSoldier, sTEAMBreathXY[posIndex], sTEAMBreathXY[posIndex + 1], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, true, FRAME_BUFFER);
            DrawMoraleUIBarEx(pSoldier, sTEAMMoraleXY[posIndex], sTEAMMoraleXY[posIndex + 1], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, true, FRAME_BUFFER);
          }

          if (gTacticalStatus.uiFlags & TURNBASED && pSoldier.bLife >= OKLIFE) {
            // Render APs
            SetFont(TINYFONT1());

            // if ( pSoldier->sLastTarget != NOWHERE && !EnoughPoints( pSoldier, MinAPsToAttack( pSoldier, pSoldier->sLastTarget, TRUE ), 0, FALSE ) || GetUIApsToDisplay( pSoldier ) < 0 )
            if (!EnoughPoints(pSoldier, MinAPsToAttack(pSoldier, pSoldier.sLastTarget, 1), 0, false) || GetUIApsToDisplay(pSoldier) < 0) {
              SetFontBackground(FONT_MCOLOR_BLACK);
              SetFontForeground(FONT_MCOLOR_DKRED);
            } else {
              if (MercUnderTheInfluence(pSoldier)) {
                SetFontBackground(FONT_MCOLOR_BLACK);
                SetFontForeground(FONT_MCOLOR_LTBLUE);
              } else if (pSoldier.bStealthMode) {
                SetFontBackground(FONT_MCOLOR_BLACK);
                SetFontForeground(FONT_MCOLOR_LTYELLOW);
              } else {
                SetFontBackground(FONT_MCOLOR_BLACK);
                SetFontForeground(FONT_MCOLOR_LTGRAY);
              }
            }
            RestoreExternBackgroundRect(sTEAMApXY[posIndex], sTEAMApXY[posIndex + 1], TM_AP_WIDTH, TM_AP_HEIGHT);

            if (gTacticalStatus.uiFlags & INCOMBAT) {
              ({ sX: sFontX, sY: sFontY } = VarFindFontCenterCoordinates(sTEAMApXY[posIndex], sTEAMApXY[posIndex + 1], TM_AP_WIDTH, TM_AP_HEIGHT, TINYFONT1(), "%d", GetUIApsToDisplay(pSoldier)));
              mprintf(sFontX, sTEAMApXY[posIndex + 1], "%d", GetUIApsToDisplay(pSoldier));
            }
          }
        } else {
          // Erase!
          // DrawUIBar( pSoldier->bBreath, sTEAMBreathXY[ posIndex ], sTEAMBreathXY[ posIndex + 1 ], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, DRAW_ERASE_BAR );
          // DrawUIBar( pSoldier->bLife, sTEAMLifeXY[ posIndex ], sTEAMLifeXY[ posIndex + 1 ], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, DRAW_ERASE_BAR );

          // Erase APs
          RestoreExternBackgroundRect(sTEAMApXY[posIndex], sTEAMApXY[posIndex + 1], TM_AP_WIDTH, TM_AP_HEIGHT);
        }
      }

      RenderSoldierTeamInv(pSoldier, sTEAMHandInvXY[posIndex], sTEAMHandInvXY[posIndex + 1], cnt, fDirty);

      HandleSoldierFaceFlash(pSoldier, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1]);

      if (!(guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
        // HandlePanelFaceAnimations( pSoldier );
      }
    }
  }
  UpdateTEAMPanel();

  if (fRenderRadarScreen == true) {
    // Render clock
    // RenderClock( CLOCK_X, CLOCK_Y );
    CreateMouseRegionForPauseOfClock(CLOCK_REGION_START_X, CLOCK_REGION_START_Y);
  } else {
    RemoveMouseRegionForPauseOfClock();
  }
}

export function CreateTEAMPanelButtons(): boolean {
  let ubString: string /* UINT8[48] */;

  ubString = FilenameForBPP("INTERFACE\\bottom_bar_buttons.sti");

  // Load button Graphics
  iTEAMPanelImages[Enum219.ENDTURN_IMAGES] = LoadButtonImage(ubString, -1, 0, -1, 3, -1);
  iTEAMPanelImages[Enum219.ROSTERMODE_IMAGES] = UseLoadedButtonImage(iTEAMPanelImages[Enum219.ENDTURN_IMAGES], -1, 1, -1, 4, -1);
  iTEAMPanelImages[Enum219.DISK_IMAGES] = UseLoadedButtonImage(iTEAMPanelImages[Enum219.ENDTURN_IMAGES], -1, 2, -1, 5, -1);

  // Create buttons
  iTEAMPanelButtons[Enum221.TEAM_DONE_BUTTON] = QuickCreateButton(iTEAMPanelImages[Enum219.ENDTURN_IMAGES], TM_ENDTURN_X, TM_ENDTURN_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnEndTurnCallback);
  if (iTEAMPanelButtons[Enum221.TEAM_DONE_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  SetButtonFastHelpText(iTEAMPanelButtons[Enum221.TEAM_DONE_BUTTON], TacticalStr[Enum335.END_TURN_POPUPTEXT]);

  iTEAMPanelButtons[Enum221.TEAM_MAP_SCREEN_BUTTON] = QuickCreateButton(iTEAMPanelImages[Enum219.ROSTERMODE_IMAGES], TM_ROSTERMODE_X, TM_ROSTERMODE_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnRostermodeCallback);
  if (iTEAMPanelButtons[Enum221.TEAM_MAP_SCREEN_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  SetButtonFastHelpText(iTEAMPanelButtons[Enum221.TEAM_MAP_SCREEN_BUTTON], TacticalStr[Enum335.MAPSCREEN_POPUPTEXT]);

  iTEAMPanelButtons[Enum221.CHANGE_SQUAD_BUTTON] = QuickCreateButton(iTEAMPanelImages[Enum219.DISK_IMAGES], TM_DISK_X, TM_DISK_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK(), BtnSquadCallback);
  if (iTEAMPanelButtons[Enum221.CHANGE_SQUAD_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return false;
  }
  SetButtonFastHelpText(iTEAMPanelButtons[Enum221.CHANGE_SQUAD_BUTTON], TacticalStr[Enum335.CHANGE_SQUAD_POPUPTEXT]);

  return true;
}

export function RemoveTEAMPanelButtons(): void {
  let cnt: UINT32;

  for (cnt = 0; cnt < Enum221.NUM_TEAM_BUTTONS; cnt++) {
    RemoveButton(iTEAMPanelButtons[cnt]);
  }

  for (cnt = 0; cnt < Enum219.NUM_TEAM_BUTTON_IMAGES; cnt++) {
    UnloadButtonImage(iTEAMPanelImages[cnt]);
  }
}

function BtnEndTurnCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    // END TURN
    UIHandleEndTurn(null);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnRostermodeCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    if (guiCurrentScreen == Enum26.GAME_SCREEN) {
      GoToMapScreenFromTactical();
      //			EnableRadarScreenRender( );
    }
  }
}

// callback to handle squad switching callback
function BtnSquadCallback(btn: GUI_BUTTON, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);

    // ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, L"Not Implemented Yet" );
    ToggleRadarScreenRender();
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

export function SetTEAMPanelCurrentMerc(ubNewID: UINT8): void {
  // Ignore ther ID given!
  // ALWYAS USE CURRENT MERC!

  fInterfacePanelDirty = DIRTYLEVEL2;

  UpdateTEAMPanel();
}

function UpdateTEAMPanel(): void {
  let cnt: INT32;

  if ((gTacticalStatus.ubCurrentTeam != gbPlayerNum) || (gTacticalStatus.uiFlags & REALTIME) || !(gTacticalStatus.uiFlags & INCOMBAT)) {
    DisableButton(iTEAMPanelButtons[Enum221.TEAM_DONE_BUTTON]);
  } else {
    EnableButton(iTEAMPanelButtons[Enum221.TEAM_DONE_BUTTON]);
  }

  if (gTacticalStatus.uiFlags & ENGAGED_IN_CONV) {
    DisableButton(iTEAMPanelButtons[Enum221.TEAM_MAP_SCREEN_BUTTON]);
  } else {
    EnableButton(iTEAMPanelButtons[Enum221.TEAM_MAP_SCREEN_BUTTON]);
  }

  if (gfDisableTacticalPanelButtons) {
    DisableButton(iTEAMPanelButtons[Enum221.TEAM_DONE_BUTTON]);
    DisableButton(iTEAMPanelButtons[Enum221.TEAM_MAP_SCREEN_BUTTON]);
    DisableButton(iTEAMPanelButtons[Enum221.CHANGE_SQUAD_BUTTON]);

    // OK, disable item regions.......
    for (cnt = 0; cnt < 6; cnt++) {
      MSYS_DisableRegion(gTEAM_EnemyIndicator[cnt]);

      MSYS_DisableRegion(gTEAM_FirstHandInv[cnt]);

      MSYS_DisableRegion(gTEAM_SecondHandInv[cnt]);
    }

    // disable the radar map region
    // If NOT in overhead map
    if (!InOverheadMap()) {
      MSYS_DisableRegion(gRadarRegion);
    }
  } else {
    EnableButton(iTEAMPanelButtons[Enum221.CHANGE_SQUAD_BUTTON]);

    for (cnt = 0; cnt < 6; cnt++) {
      MSYS_EnableRegion(gTEAM_EnemyIndicator[cnt]);

      MSYS_EnableRegion(gTEAM_FirstHandInv[cnt]);

      MSYS_EnableRegion(gTEAM_SecondHandInv[cnt]);
    }

    // Enable the radar map region
    MSYS_EnableRegion(gRadarRegion);
  }
}

function HandleMouseOverTeamFaceForContMove(fOn: boolean): void {
  let pFace: FACETYPE;

  if (fOn) {
    // Check if we are waiting to continue move...
    if (CheckForMercContMove(gpSMCurrentMerc)) {
      // Display 'cont' on face....
      // Get face
      pFace = gFacesData[gpSMCurrentMerc.iFaceIndex];

      pFace.fDisplayTextOver = FACE_DRAW_TEXT_OVER;
      pFace.zDisplayText = TacticalStr[Enum335.CONTINUE_OVER_FACE_STR];

      // While our mouse is here, draw a path!
      PlotPath(gpSMCurrentMerc, gpSMCurrentMerc.sFinalDestination, NO_COPYROUTE, PLOT, TEMPORARY, gpSMCurrentMerc.usUIMovementMode, NOT_STEALTH, FORWARD, gpSMCurrentMerc.bActionPoints);
    }
  } else {
    // Remove 'cont' on face....
    // Get face
    pFace = gFacesData[gpSMCurrentMerc.iFaceIndex];

    pFace.fDisplayTextOver = FACE_ERASE_TEXT_OVER;

    // Erase path!
    ErasePath(true);
  }
}

function MercFacePanelMoveCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let pSoldier: SOLDIERTYPE;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  // If our flags are set to do this, gofoit!
  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    return;
  }

  if (ubID == NOBODY) {
    return;
  }

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY) {
    return;
  }

  pSoldier = MercPtrs[ubSoldierID];

  if (!pSoldier.bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_MOVE) {
    HandleMouseOverSoldierFaceForContMove(pSoldier, true);
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    HandleMouseOverSoldierFaceForContMove(pSoldier, false);
  }
}

function EnemyIndicatorClickCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  if (ubID == NOBODY) {
    return;
  }

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (!MercPtrs[ubSoldierID].bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    if (MercPtrs[ubSoldierID].uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
    } else {
      let pSoldier: SOLDIERTYPE;

      pSoldier = MercPtrs[ubSoldierID];

      if (pSoldier.bOppCnt > 0) {
        // Cycle....
        CycleVisibleEnemies(pSoldier);
      } else {
        MercFacePanelCallback(pRegion, iReason);
      }
    }
  }
}

function MercFacePanelCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let pVehicle: SOLDIERTYPE;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  // If our flags are set to do this, gofoit!
  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
      SetInfoChar(ubID);
    }
    return;
  }

  if (ubID == NOBODY) {
    return;
  }

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (!MercPtrs[ubSoldierID].bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    if (!gfInItemPickupMenu && gpItemPointer == null) {
      if (MercPtrs[ubSoldierID].uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
        pVehicle = GetSoldierStructureForVehicle(MercPtrs[ubSoldierID].iVehicleId);

        HandleLocateSelectMerc(pVehicle.ubID, 0);
      } else {
        if (!InOverheadMap()) {
          // If we can continue a move, do so!
          if (CheckForMercContMove(MercPtrs[ubSoldierID])) {
            // Continue
            ContinueMercMovement(MercPtrs[ubSoldierID]);
            ErasePath(true);
          } else {
            HandleLocateSelectMerc(ubSoldierID, 0);
          }
        } else {
          SelectSoldier(ubSoldierID, true, false);
        }
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    if (!InOverheadMap()) {
      // Only if guy is not dead!
      if (!(MercPtrs[ubSoldierID].uiStatusFlags & SOLDIER_DEAD) && !AM_AN_EPC(MercPtrs[ubSoldierID]) && !(MercPtrs[ubSoldierID].uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER))) {
        gfSwitchPanel = true;
        gbNewPanel = Enum215.SM_PANEL;
        gubNewPanelParam = ubSoldierID;
      }
    }
  }
}

export function HandleLocateSelectMerc(ubID: UINT8, bFlag: INT8): void {
  let fSelect: boolean = false;

  if (!MercPtrs[ubID].bActive) {
    return;
  }

  if (gpItemPointer != null) {
    // ATE: Disable for feel purposes....
    // return;
  }

  // ATE: No matter what we do... if below OKLIFE, just locate....
  if (MercPtrs[ubID].bLife < OKLIFE) {
    LocateSoldier(ubID, SETLOCATOR);
    return;
  }

  if (_KeyDown(ALT)) {
    if (gGameSettings.fOptions[Enum8.TOPTION_OLD_SELECTION_METHOD]) {
      // Select merc
      InternalSelectSoldier(ubID, true, false, true);
      MercPtrs[ubID].fFlashLocator = 0;
      ResetMultiSelection();
    } else {
      // Just locate....
      LocateSoldier(ubID, SETLOCATOR);
    }
  } else {
    if (MercPtrs[ubID].fFlashLocator == 0) {
      if (gGameSettings.fOptions[Enum8.TOPTION_OLD_SELECTION_METHOD]) {
        // If we are currently selected, slide to location
        if (ubID == gusSelectedSoldier) {
          SlideTo(NOWHERE, gusSelectedSoldier, NOBODY, SETLOCATOR);
        } else {
          LocateSoldier(ubID, SETLOCATOR);
        }
      } else {
        if (ubID == gusSelectedSoldier) {
          SlideTo(NOWHERE, gusSelectedSoldier, NOBODY, SETLOCATOR);
        } else {
          fSelect = true;
          // ShowRadioLocator( ubID, SHOW_LOCATOR_NORMAL );
        }
      }
    } else {
      if (gGameSettings.fOptions[Enum8.TOPTION_OLD_SELECTION_METHOD]) {
        // If we are currently selected, slide to location
        if (ubID == gusSelectedSoldier) {
          SlideTo(NOWHERE, gusSelectedSoldier, NOBODY, DONTSETLOCATOR);
        } else {
          LocateSoldier(ubID, DONTSETLOCATOR);
        }

        fSelect = true;
      } else {
        if (ubID == gusSelectedSoldier) {
          LocateSoldier(ubID, DONTSETLOCATOR);
        } else {
          fSelect = true;
        }
      }
    }

    if (bFlag == LOCATEANDSELECT_MERC) {
      fSelect = true;
    }

    if (fSelect) {
      // Select merc, only if alive!
      if (!(MercPtrs[ubID].uiStatusFlags & SOLDIER_DEAD)) {
        InternalSelectSoldier(ubID, true, false, true);
      }
    }
  }

  ResetMultiSelection();

  // Handle locate select merc....
  HandleMouseOverSoldierFaceForContMove(MercPtrs[ubID], true);
}

export function ShowRadioLocator(ubID: UINT8, ubLocatorSpeed: UINT8): void {
  MercPtrs[ubID].FlashSelCounter = RESETTIMECOUNTER(FLASH_SELECTOR_DELAY);

  // LocateSoldier( ubID, FALSE );	// IC - this is already being done outside of this function :)
  MercPtrs[ubID].fFlashLocator = 1;
  // gbPanelSelectedGuy = ubID;	IC - had to move this outside to make this function versatile
  MercPtrs[ubID].sLocatorFrame = 0;

  if (ubLocatorSpeed == SHOW_LOCATOR_NORMAL) {
    // If we are an AI guy, and we have the baton, make lower...
    // ( MercPtrs[ ubID ]->uiStatusFlags & SOLDIER_UNDERAICONTROL && MercPtrs[ ubID ]->bTeam != gbPlayerNum )
    //
    // ercPtrs[ ubID ]->ubNumLocateCycles = 3;
    //
    // se
    //
    MercPtrs[ubID].ubNumLocateCycles = 5;
    //
  } else {
    MercPtrs[ubID].ubNumLocateCycles = 3;
  }
}

export function EndRadioLocator(ubID: UINT8): void {
  MercPtrs[ubID].fFlashLocator = 0;
  MercPtrs[ubID].fShowLocator = false;
}

function CheckForFacePanelStartAnims(pSoldier: SOLDIERTYPE, sPanelX: INT16, sPanelY: INT16): void {
  if (!pSoldier.bActive) {
    return;
  }

  if (pSoldier.fUIdeadMerc) {
    //		pSoldier->sPanelFaceX	= sPanelX;
    //		pSoldier->sPanelFaceY	= sPanelY;
  }
}

export function FinishAnySkullPanelAnimations(): void {
  let pTeamSoldier: SOLDIERTYPE;
  let cnt2: INT32;

  cnt2 = gTacticalStatus.Team[gbPlayerNum].bFirstID;

  // run through list
  for (pTeamSoldier = MercPtrs[cnt2]; cnt2 <= gTacticalStatus.Team[gbPlayerNum].bLastID; cnt2++, pTeamSoldier = MercPtrs[cnt2]) {
    if (pTeamSoldier.bActive && pTeamSoldier.bLife == 0) {
      if (pTeamSoldier.fUIdeadMerc || pTeamSoldier.fClosePanelToDie) {
        HandlePlayerTeamMemberDeathAfterSkullAnimation(pTeamSoldier);

        pTeamSoldier.fUIdeadMerc = false;
        pTeamSoldier.fClosePanelToDie = false;
      }
    }
  }
}

export function HandlePanelFaceAnimations(pSoldier: SOLDIERTYPE): void {
  if (pSoldier.bTeam != gbPlayerNum) {
    return;
  }

  if (!pSoldier.bActive) {
    return;
  }

  if (pSoldier.uiStatusFlags & SOLDIER_VEHICLE) {
    // Don't do this for a vehice.
    return;
  }

  // If this is the first time we are active, open panel!
  if (pSoldier.fUInewMerc) {
    pSoldier.fUInewMerc = false;
  }

  if (pSoldier.fUICloseMerc) {
    pSoldier.fUICloseMerc = false;
  }

  if (pSoldier.fUIdeadMerc) {
    pSoldier.sPanelFaceX = gFacesData[pSoldier.iFaceIndex].usFaceX;
    pSoldier.sPanelFaceY = gFacesData[pSoldier.iFaceIndex].usFaceY;

    pSoldier.fUIdeadMerc = false;
    pSoldier.fClosePanel = true;
    pSoldier.fClosePanelToDie = true;
    pSoldier.ubClosePanelFrame = 0;
    pSoldier.ubDeadPanelFrame = 0;
    pSoldier.PanelAnimateCounter = RESETTIMECOUNTER(160);
  }

  if (pSoldier.fClosePanel) {
    if (TIMECOUNTERDONE(pSoldier.PanelAnimateCounter, 160)) {
      pSoldier.ubClosePanelFrame++;

      if (pSoldier.ubClosePanelFrame > 5) {
        pSoldier.fClosePanel = false;
        pSoldier.ubClosePanelFrame = 5;

        if (pSoldier.fClosePanelToDie) {
          pSoldier.fDeadPanel = true;
          // PlayJA2Sample( (UINT8)HEADCR_1, RATE_11025, HIGHVOLUME, 1, MIDDLEPAN );
        } else {
          if (!gFacesData[pSoldier.iFaceIndex].fDisabled) {
            RestoreExternBackgroundRect(pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
          }
        }
      }
      pSoldier.PanelAnimateCounter = RESETTIMECOUNTER(160);
    }
  }

  if (pSoldier.fClosePanel) {
    // Render panel!
    // if(gbPixelDepth==16)
    //{
    if (!gFacesData[pSoldier.iFaceIndex].fDisabled) {
      RestoreExternBackgroundRect(pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
      BltVideoObjectFromIndex(FRAME_BUFFER, guiCLOSE, pSoldier.ubClosePanelFrame, pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, null);
      InvalidateRegion(pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, pSoldier.sPanelFaceX + TM_FACE_WIDTH, pSoldier.sPanelFaceY + TM_FACE_HEIGHT);
    }
    //}
  }

  if (pSoldier.fDeadPanel) {
    if (TIMECOUNTERDONE(pSoldier.PanelAnimateCounter, 160)) {
      pSoldier.ubDeadPanelFrame++;

      if (pSoldier.ubDeadPanelFrame == 4) {
        ScreenMsg(FONT_RED, MSG_SKULL_UI_FEEDBACK, pMercDeadString[0], pSoldier.name);

        PlayJA2Sample(Enum330.DOORCR_1, RATE_11025, HIGHVOLUME, 1, MIDDLEPAN);
        PlayJA2Sample(Enum330.HEADCR_1, RATE_11025, HIGHVOLUME, 1, MIDDLEPAN);
      }

      if (pSoldier.ubDeadPanelFrame > 5) {
        pSoldier.fDeadPanel = false;
        pSoldier.ubDeadPanelFrame = 5;
        pSoldier.fClosePanelToDie = false;

        // Finish!
        if (!gFacesData[pSoldier.iFaceIndex].fDisabled) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiDEAD, pSoldier.ubDeadPanelFrame, pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, null);

          // Blit hatch!
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiHATCH, 0, pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, null);

          RestoreExternBackgroundRect(pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
        }
        HandlePlayerTeamMemberDeathAfterSkullAnimation(pSoldier);
      }
      pSoldier.PanelAnimateCounter = RESETTIMECOUNTER(160);
    }
  }

  if (pSoldier.fDeadPanel) {
    // Render panel!
    // if(gbPixelDepth==16)
    //{
    if (!gFacesData[pSoldier.iFaceIndex].fDisabled) {
      BltVideoObjectFromIndex(FRAME_BUFFER, guiDEAD, pSoldier.ubDeadPanelFrame, pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, null);

      // Blit hatch!
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiHATCH, 0, pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, null);

      InvalidateRegion(pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, pSoldier.sPanelFaceX + TM_FACE_WIDTH, pSoldier.sPanelFaceY + TM_FACE_HEIGHT);
    }
    //}
  }

  if (pSoldier.fOpenPanel) {
    if (TIMECOUNTERDONE(pSoldier.PanelAnimateCounter, 160)) {
      pSoldier.bOpenPanelFrame--;

      if (pSoldier.bOpenPanelFrame < 0) {
        pSoldier.fOpenPanel = false;
        pSoldier.bOpenPanelFrame = 0;

        if (!gFacesData[pSoldier.iFaceIndex].fDisabled) {
          RestoreExternBackgroundRect(pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
        }
      }
      pSoldier.PanelAnimateCounter = RESETTIMECOUNTER(160);
    }
  }

  if (pSoldier.fOpenPanel) {
    // Render panel!
    // if(gbPixelDepth==16)
    //{
    if (!gFacesData[pSoldier.iFaceIndex].fDisabled) {
      RestoreExternBackgroundRect(pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
      BltVideoObjectFromIndex(FRAME_BUFFER, guiCLOSE, pSoldier.bOpenPanelFrame, pSoldier.sPanelFaceX, pSoldier.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, null);
      // InvalidateRegion( sTEAMFacesXY[ ubOpenPanelID ], sTEAMFacesXY[ ubOpenPanelID + 1 ], sTEAMFacesXY[ ubOpenPanelID ] + TM_FACE_WIDTH, sTEAMFacesXY[ ubOpenPanelID + 1 ] + TM_FACE_HEIGHT );
    }
    //}
  }
}

function HandleSoldierFaceFlash(pSoldier: SOLDIERTYPE, sFaceX: INT16, sFaceY: INT16): void {
}

function RenderSoldierTeamInv(pSoldier: SOLDIERTYPE, sX: INT16, sY: INT16, ubPanelNum: UINT8, fDirty: UINT8 /* boolean */): void {
  if (pSoldier.bActive && !(pSoldier.uiStatusFlags & SOLDIER_DEAD)) {
    if (pSoldier.uiStatusFlags & SOLDIER_DRIVER) {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiVEHINV, 0, sX, sY, VO_BLT_SRCTRANSPARENCY, null);
      RestoreExternBackgroundRect(sX, sY, (TM_INV_WIDTH), (TM_INV_HEIGHT));
    } else {
      // Look in primary hand
      INVRenderItem(guiSAVEBUFFER, pSoldier, pSoldier.inv[Enum261.HANDPOS], sX, sY, TM_INV_WIDTH, TM_INV_HEIGHT, fDirty, createElementPointer(gfTEAM_HandInvDispText[ubPanelNum], Enum261.HANDPOS), 0, false, 0);
    }

    if (pSoldier.uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiVEHINV, 1, sX, (sY + TM_INV_HAND_SEPY), VO_BLT_SRCTRANSPARENCY, null);
      RestoreExternBackgroundRect(sX, (sY + TM_INV_HAND_SEPY), (TM_INV_WIDTH), (TM_INV_HEIGHT));
    } else {
      // Do secondary hand
      INVRenderItem(guiSAVEBUFFER, pSoldier, pSoldier.inv[Enum261.SECONDHANDPOS], sX, (sY + TM_INV_HAND_SEPY), TM_INV_WIDTH, TM_INV_HEIGHT, fDirty, createElementPointer(gfTEAM_HandInvDispText[ubPanelNum], Enum261.SECONDHANDPOS), 0, false, 0);
    }
  }
}

function TMFirstHandInvCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  // If our flags are set to do this, gofoit!
  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (ubID == NOBODY)
    return;

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (!MercPtrs[ubSoldierID].bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    // OK FOR NOW, DROP ITEM WHERE BUDDY IS
    {
      //	SOLDIERTYPE *pSoldier;

      //	if(	GetSoldier( &pSoldier, ubSoldierID ) )
      //	{
      //	}
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
  }
}

function TMClickFirstHandInvCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let usOldHandItem: UINT16;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  if (ubID == NOBODY)
    return;

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY)
    return;

  if (iReason == MSYS_CALLBACK_REASON_LBUTTON_UP) {
    // Change to use cursor mode...
    guiPendingOverrideEvent = Enum207.A_ON_TERRAIN;
  }

  if (iReason == MSYS_CALLBACK_REASON_RBUTTON_UP) {
    if (!AM_A_ROBOT(MercPtrs[ubSoldierID])) {
      usOldHandItem = MercPtrs[ubSoldierID].inv[Enum261.HANDPOS].usItem;
      // SwapOutHandItem( MercPtrs[ ubSoldierID ] );
      SwapHandItems(MercPtrs[ubSoldierID]);
      ReLoadSoldierAnimationDueToHandItemChange(MercPtrs[ubSoldierID], usOldHandItem, MercPtrs[ubSoldierID].inv[Enum261.HANDPOS].usItem);
      fInterfacePanelDirty = DIRTYLEVEL2;
    }
  }
}

function TMClickSecondHandInvCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let usOldHandItem: UINT16;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  if (ubID == NOBODY)
    return;

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY)
    return;

  if (iReason == MSYS_CALLBACK_REASON_LBUTTON_UP) {
    if (MercPtrs[ubSoldierID].uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
      ExitVehicle(MercPtrs[ubSoldierID]);
    }
  }

  if (iReason == MSYS_CALLBACK_REASON_RBUTTON_UP) {
    if (MercPtrs[ubSoldierID].uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
    } else {
      if (!AM_A_ROBOT(MercPtrs[ubSoldierID])) {
        usOldHandItem = MercPtrs[ubSoldierID].inv[Enum261.HANDPOS].usItem;
        SwapHandItems(MercPtrs[ubSoldierID]);
        ReLoadSoldierAnimationDueToHandItemChange(MercPtrs[ubSoldierID], usOldHandItem, MercPtrs[ubSoldierID].inv[Enum261.HANDPOS].usItem);
        fInterfacePanelDirty = DIRTYLEVEL2;
      }
    }
  }
}

function PlayerExistsInSlot(ubID: UINT8): boolean {
  let cnt: INT32;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      if (gTeamPanel[cnt].ubID == ubID) {
        return true;
      }
    }
  }

  return false;
}

function GetTeamSlotFromPlayerID(ubID: UINT8): INT8 {
  let cnt: INT8;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      if (gTeamPanel[cnt].ubID == ubID) {
        return cnt;
      }
    }
  }

  return -1;
}

export function RemovePlayerFromTeamSlotGivenMercID(ubMercID: UINT8): boolean {
  let cnt: INT32;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      if (gTeamPanel[cnt].ubID == ubMercID) {
        RemovePlayerFromInterfaceTeamSlot(cnt);
        return true;
      }
    }
  }

  return false;
}

export function AddPlayerToInterfaceTeamSlot(ubID: UINT8): void {
  let cnt: INT32;

  // If we are a vehicle don't ever add.....
  if (MercPtrs[ubID].uiStatusFlags & SOLDIER_VEHICLE) {
    return;
  }

  if (!PlayerExistsInSlot(ubID)) {
    // Find a free slot
    for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
      if (!gTeamPanel[cnt].fOccupied) {
        gTeamPanel[cnt].fOccupied = true;
        gTeamPanel[cnt].ubID = ubID;

        MSYS_SetRegionUserData(gTEAM_FirstHandInv[cnt], 0, cnt);
        MSYS_SetRegionUserData(gTEAM_FaceRegions[cnt], 0, cnt);

        // DIRTY INTERFACE
        fInterfacePanelDirty = DIRTYLEVEL2;

        // Set ID to do open anim
        MercPtrs[ubID].fUInewMerc = true;

        break;
      }
    }
  }
}

export function InitTEAMSlots(): boolean {
  let cnt: INT32;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    gTeamPanel[cnt].fOccupied = false;
    gTeamPanel[cnt].ubID = NOBODY;
  }

  return true;
}

export function GetPlayerIDFromInterfaceTeamSlot(ubPanelSlot: UINT8, pubID: Pointer<UINT8>): boolean {
  if (ubPanelSlot >= NUM_TEAM_SLOTS) {
    return false;
  }

  if (gTeamPanel[ubPanelSlot].fOccupied) {
    pubID.value = gTeamPanel[ubPanelSlot].ubID;
    return true;
  } else {
    return false;
  }
}

export function RemoveAllPlayersFromSlot(): void {
  let cnt: number;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    RemovePlayerFromInterfaceTeamSlot(cnt);
  }
}

function RemovePlayerFromInterfaceTeamSlot(ubPanelSlot: UINT8): boolean {
  if (ubPanelSlot >= NUM_TEAM_SLOTS) {
    return false;
  }

  if (gTeamPanel[ubPanelSlot].fOccupied) {
    if (!(MercPtrs[gTeamPanel[ubPanelSlot].ubID].uiStatusFlags & SOLDIER_DEAD)) {
      // Set Id to close
      MercPtrs[gTeamPanel[ubPanelSlot].ubID].fUICloseMerc = true;
    }

    // Set face to inactive...
    SetAutoFaceInActive(MercPtrs[gTeamPanel[ubPanelSlot].ubID].iFaceIndex);

    gTeamPanel[ubPanelSlot].fOccupied = false;
    gTeamPanel[ubPanelSlot].ubID = NOBODY;

    MSYS_SetRegionUserData(gTEAM_FirstHandInv[ubPanelSlot], 0, NOBODY);
    MSYS_SetRegionUserData(gTEAM_FaceRegions[ubPanelSlot], 0, NOBODY);

    // DIRTY INTERFACE
    fInterfacePanelDirty = DIRTYLEVEL2;

    return true;
  } else {
    return false;
  }
}

export function RenderTownIDString(): void {
  let zTownIDString: string /* CHAR16[80] */;
  let sFontX: INT16;
  let sFontY: INT16;

  // Render town, position
  SetFont(COMPFONT());
  SetFontForeground(183);
  SetFontBackground(FONT_BLACK);

  zTownIDString = GetSectorIDString(gWorldSectorX, gWorldSectorY, gbWorldSectorZ, true);
  zTownIDString = ReduceStringLength(zTownIDString, 80, COMPFONT());
  ({ sX: sFontX, sY: sFontY } = VarFindFontCenterCoordinates(548, 425, 80, 16, COMPFONT(), zTownIDString));
  mprintf(sFontX, sFontY, "%s", zTownIDString);
}

export function CheckForAndAddMercToTeamPanel(pSoldier: SOLDIERTYPE): void {
  if (pSoldier.bActive) {
    // Add to interface if the are ours
    if (pSoldier.bTeam == gbPlayerNum) {
      // Are we in the loaded sector?
      if (pSoldier.sSectorX == gWorldSectorX && pSoldier.sSectorY == gWorldSectorY && pSoldier.bSectorZ == gbWorldSectorZ && !pSoldier.fBetweenSectors && pSoldier.bInSector) {
        // IF on duty....
        if ((pSoldier.bAssignment == CurrentSquad()) || (SoldierIsDeadAndWasOnSquad(pSoldier, (CurrentSquad())))) {
          if (pSoldier.bAssignment == Enum117.ASSIGNMENT_DEAD) {
            pSoldier.fUICloseMerc = false;
          }
          // ATE: ALrighty, if we have the insertion code of helicopter..... don't add just yet!
          /// ( will add in heli code )
          if (pSoldier.ubStrategicInsertionCode != Enum175.INSERTION_CODE_CHOPPER) {
            AddPlayerToInterfaceTeamSlot(pSoldier.ubID);
          }

          // ARE WE A VEHICLE.....
          if (pSoldier.uiStatusFlags & SOLDIER_VEHICLE) {
            AddPassangersToTeamPanel(pSoldier.bVehicleID);
          }
        }
      } else {
        // Make sure we are NOT in this world!
        // Set gridno to one that's not visib;l
        RemoveSoldierFromGridNo(pSoldier);

        // Remove slot from tactical
        RemoveMercSlot(pSoldier);
      }
    }
  }
}

export function FindNextMercInTeamPanel(pSoldier: SOLDIERTYPE, fGoodForLessOKLife: boolean, fOnlyRegularMercs: boolean): UINT8 {
  let cnt: INT32;
  let bFirstID: INT32;
  let pTeamSoldier: SOLDIERTYPE;

  bFirstID = GetTeamSlotFromPlayerID(pSoldier.ubID);

  if (bFirstID == -1) {
    return pSoldier.ubID;
  }

  for (cnt = (bFirstID + 1); cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      // Set Id to close
      pTeamSoldier = MercPtrs[gTeamPanel[cnt].ubID];

      if (fOnlyRegularMercs) {
        if (pTeamSoldier.bActive && (AM_AN_EPC(pTeamSoldier) || AM_A_ROBOT(pTeamSoldier))) {
          continue;
        }
      }

      if (fGoodForLessOKLife) {
        if (pTeamSoldier.bLife > 0 && pTeamSoldier.bActive && pTeamSoldier.bInSector && pTeamSoldier.bTeam == gbPlayerNum && pTeamSoldier.bAssignment < Enum117.ON_DUTY && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.bAssignment == pTeamSoldier.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      } else {
        if (OK_CONTROLLABLE_MERC(pTeamSoldier) && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.bAssignment == pTeamSoldier.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      }
    }
  }

  // none found,
  // Now loop back
  for (cnt = 0; cnt < bFirstID; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      pTeamSoldier = MercPtrs[gTeamPanel[cnt].ubID];

      if (fOnlyRegularMercs) {
        if (pTeamSoldier.bActive && (AM_AN_EPC(pTeamSoldier) || AM_A_ROBOT(pTeamSoldier))) {
          continue;
        }
      }

      if (fGoodForLessOKLife) {
        if (pTeamSoldier.bLife > 0 && pTeamSoldier.bActive && pTeamSoldier.bInSector && pTeamSoldier.bTeam == gbPlayerNum && pTeamSoldier.bAssignment < Enum117.ON_DUTY && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.bAssignment == pTeamSoldier.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      } else {
        if (OK_CONTROLLABLE_MERC(pTeamSoldier) && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.bAssignment == pTeamSoldier.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      }
    }
  }

  // IF we are here, keep as we always were!
  return pSoldier.ubID;
}

export function HelpTextDoneCallback(): void {
  gfRerenderInterfaceFromHelpText = true;

  // To redraw the Store Keeper Interface
  gubSkiDirtyLevel = Enum253.SKI_DIRTY_LEVEL2;
}

export function DisableTacticalTeamPanelButtons(fDisable: boolean): void {
  gfDisableTacticalPanelButtons = fDisable;
}

export function BeginKeyPanelFromKeyShortcut(): void {
  let pSoldier: SOLDIERTYPE;
  let sStartYPosition: INT16 = 0;
  let sWidth: INT16 = 0;
  let sHeight: INT16 = 0;

  if (gsCurInterfacePanel != Enum215.SM_PANEL) {
    return;
  }

  if (gpSMCurrentMerc == null) {
    return;
  }

  if (gfInKeyRingPopup) {
    return;
  }

  sStartYPosition = INV_INTERFACE_START_Y;
  sWidth = 640;
  sHeight = (480 - (INV_INTERFACE_START_Y));
  pSoldier = gpSMCurrentMerc;

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  InitKeyRingPopup(pSoldier, 0, sStartYPosition, sWidth, sHeight);
}

export function KeyRingItemPanelButtonCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let pSoldier: SOLDIERTYPE;
  let sStartYPosition: INT16 = 0;
  let sWidth: INT16 = 0;
  let sHeight: INT16 = 0;

  if (guiCurrentScreen == Enum26.MAP_SCREEN) {
    if (bSelectedInfoChar == -1) {
      return;
    }

    if (gCharactersList[bSelectedInfoChar].fValid == false) {
      return;
    }

    pSoldier = Menptr[gCharactersList[bSelectedInfoChar].usSolID];
    sStartYPosition = MAP_START_KEYRING_Y;
    sWidth = 261;
    sHeight = (359 - 107);
  } else {
    if (gpSMCurrentMerc == null) {
      return;
    }

    sStartYPosition = INV_INTERFACE_START_Y;
    sWidth = 640;
    sHeight = (480 - (INV_INTERFACE_START_Y));
    pSoldier = gpSMCurrentMerc;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    if (guiCurrentScreen == Enum26.MAP_SCREEN) {
      // want the inv done button shutdown and the region behind the keyring shaded
      // ForceButtonUnDirty( giMapInvDoneButton );
      // shade the background
      ShadowVideoSurfaceRect(FRAME_BUFFER, 0, 107, 261, 359);
      InvalidateRegion(0, 107, 261, 359);
    }

    InitKeyRingPopup(pSoldier, 0, sStartYPosition, sWidth, sHeight);
  }
}

/* static */ let KeyRingSlotInvClickCallback__fRightDown: boolean = false;
/* static */ let KeyRingSlotInvClickCallback__fLeftDown: boolean = false;
export function KeyRingSlotInvClickCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  let uiKeyRing: UINT32;
  // Copyies of values
  let usOldItemIndex: UINT16;
  let iNumberOfKeysTaken: INT32 = 0;

  uiKeyRing = MSYS_GetRegionUserData(pRegion, 0);

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  // if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
  //{
  //	fLeftDown = TRUE;
  //}
  // else if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP && fLeftDown )
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    KeyRingSlotInvClickCallback__fLeftDown = false;

    // if we are in the shop keeper interface
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
      let InvSlot: INVENTORY_IN_SLOT = createInventoryInSlot();

      if (gMoveingItem.sItemIndex == 0) {
        // Delete the contents of the item cursor
        resetInventoryInSlot(gMoveingItem);
      } else {
        resetInventoryInSlot(InvSlot);

        // Return if empty
        // if ( gpSMCurrentMerc->inv[ uiHandPos ].usItem == NOTHING )
        //	return;

        // Fill out the inv slot for the item
        // InvSlot.sItemIndex = gpSMCurrentMerc->inv[ uiHandPos ].usItem;
        //			InvSlot.ubNumberOfItems = gpSMCurrentMerc->inv[ uiHandPos ].ubNumberOfObjects;
        //			InvSlot.ubItemQuality = gpSMCurrentMerc->inv[ uiHandPos ].bGunStatus;
        // memcpy( &InvSlot.ItemObject, &gpSMCurrentMerc->inv[ uiHandPos ], sizeof( OBJECTTYPE ) );
        // InvSlot.ubLocationOfObject = PLAYERS_INVENTORY;

        // InvSlot.ubIdOfMercWhoOwnsTheItem = gpSMCurrentMerc->ubProfile;

        // Add the item to the Players Offer Area
        // AddItemToPlayersOfferArea( gpSMCurrentMerc->ubProfile, &InvSlot, (UINT8)uiHandPos );

        // Dirty
        fInterfacePanelDirty = DIRTYLEVEL2;
      }
      return;
    }

    // If we do not have an item in hand, start moving it
    if (gpItemPointer == null) {
      // Return if empty
      if ((gpItemPopupSoldier.pKeyRing[uiKeyRing].ubKeyID == INVALID_KEY_NUMBER) || (gpItemPopupSoldier.pKeyRing[uiKeyRing].ubNumber == 0))
        return;

      // If our flags are set to do this, gofoit!
      if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
      } else {
        if (gpItemPopupSoldier.ubID != gusSelectedSoldier) {
          SelectSoldier(gpItemPopupSoldier.ubID, false, false);
        }
      }

      usOldItemIndex = uiKeyRing;

      BeginKeyRingItemPointer(gpItemPopupSoldier, usOldItemIndex);
      // BeginItemPointer( gpSMCurrentMerc, (UINT8)uiHandPos );
    } else {
      let ubSrcID: UINT8;
      let ubDestID: UINT8;
      let fOKToGo: boolean = false;
      let fDeductPoints: boolean = false;

      if ((gpItemPointer.usItem < FIRST_KEY) || (gpItemPointer.usItem > Enum225.KEY_32)) {
        return;
      }

      // ATE: OK, get source, dest guy if different... check for and then charge appropriate APs
      ubSrcID = gCharactersList[bSelectedInfoChar].usSolID;
      if (gpItemPointerSoldier) {
        ubDestID = gpItemPointerSoldier.ubID;
      } else {
        ubDestID = ubSrcID;
      }

      if (ubSrcID == ubDestID) {
        // We are doing this ourselve, continue
        fOKToGo = true;
      } else {
        // These guys are different....
        fDeductPoints = true;

        // First check points for src guy
        if (gpItemPointerSoldier.bLife >= CONSCIOUSNESS) {
          if (EnoughPoints(gpItemPointerSoldier, 2, 0, true)) {
            fOKToGo = true;
          }
        } else {
          fOKToGo = true;
        }

        // Should we go on?
        if (fOKToGo) {
          if (gpSMCurrentMerc.bLife >= CONSCIOUSNESS) {
            if (EnoughPoints(gpSMCurrentMerc, 2, 0, true)) {
              fOKToGo = true;
            } else {
              fOKToGo = false;
            }
          }
        }
      }

      if (fOKToGo) {
        // usOldItemIndex = gpSMCurrentMerc->inv[ uiHandPos ].usItem;
        // usNewItemIndex = gpItemPointer->usItem;

        if (gpItemPopupSoldier.pKeyRing[uiKeyRing].ubKeyID == INVALID_KEY_NUMBER || gpItemPopupSoldier.pKeyRing[uiKeyRing].ubKeyID == gpItemPointer.ubKeyID) {
          // Try to place here
          if ((iNumberOfKeysTaken = AddKeysToSlot(gpItemPopupSoldier, uiKeyRing, gpItemPointer))) {
            if (fDeductPoints) {
              // Deduct points
              if (gpItemPointerSoldier.bLife >= CONSCIOUSNESS) {
                DeductPoints(gpItemPointerSoldier, 2, 0);
              }
              if (gpItemPopupSoldier.bLife >= CONSCIOUSNESS) {
                DeductPoints(gpItemPopupSoldier, 2, 0);
              }
            }

            // Dirty
            fInterfacePanelDirty = DIRTYLEVEL2;

            gpItemPointer.ubNumberOfObjects -= iNumberOfKeysTaken;

            // Check if it's the same now!
            if (gpItemPointer.ubNumberOfObjects == 0) {
              if (guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN) {
                MAPEndItemPointer();
              } else {
                EndItemPointer();
              }
            }

            // Setup a timer....
            // guiMouseOverItemTime = GetJA2Clock( );
            // gfCheckForMouseOverItem = TRUE;
            // gbCheckForMouseOverItemPos = (INT8)uiHandPos;
          }
        } else {
          // Swap!
          SwapKeysToSlot(gpItemPopupSoldier, uiKeyRing, gpItemPointer);

          if (fDeductPoints) {
            // Deduct points
            if (gpItemPointerSoldier && gpItemPointerSoldier.bLife >= CONSCIOUSNESS) {
              DeductPoints(gpItemPointerSoldier, 2, 0);
            }
            if (gpSMCurrentMerc.bLife >= CONSCIOUSNESS) {
              DeductPoints(gpSMCurrentMerc, 2, 0);
            }
          }

          // Dirty
          fInterfacePanelDirty = DIRTYLEVEL2;
        }
      }
    }

    UpdateItemHatches();
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    KeyRingSlotInvClickCallback__fRightDown = true;
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_UP && KeyRingSlotInvClickCallback__fRightDown) {
    KeyRingSlotInvClickCallback__fRightDown = false;

    // Return if empty
    if ((gpItemPopupSoldier.pKeyRing[uiKeyRing].ubKeyID == INVALID_KEY_NUMBER) || (gpItemPopupSoldier.pKeyRing[uiKeyRing].ubNumber == 0)) {
      DeleteKeyRingPopup();
      fTeamPanelDirty = true;
      return;
    }
    // Some global stuff here - for esc, etc
    // Check for # of slots in item
    if (!InItemDescriptionBox()) {
      if (guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN) {
        // InitKeyItemDescriptionBox( gpItemPopupSoldier, (UINT8)uiKeyRing, MAP_ITEMDESC_START_X, MAP_ITEMDESC_START_Y, 0 );
      } else {
        InitKeyItemDescriptionBox(gpItemPopupSoldier, uiKeyRing, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0);
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    KeyRingSlotInvClickCallback__fRightDown = false;
    KeyRingSlotInvClickCallback__fLeftDown = false;
  }
}

export function DisableSMPpanelButtonsWhenInShopKeeperInterface(fDontDrawButtons: boolean): void {
  // Go through the buttons that will be under the ShopKeepers ATM panel and disable them
  DisableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.UPDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.BURSTMODE_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.LOOK_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.TALK_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.MUTE_BUTTON]);

  DisableButton(giSMStealthButton);

  // Make sure the options button is disabled
  DisableButton(iSMPanelButtons[Enum220.OPTIONS_BUTTON]);

  // Make sure the mapscreen button is disabled
  DisableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);

  DisableButton(iSMPanelButtons[Enum220.STANCEUP_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.UPDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.CLIMB_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.BURSTMODE_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.LOOK_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.TALK_BUTTON]);
  DisableButton(iSMPanelButtons[Enum220.MUTE_BUTTON]);

  DisableButton(giSMStealthButton);

  if (fDontDrawButtons) {
    // ATM:

    // Go through the buttons that will be under the ShopKeepers ATM panel and disable them
    ButtonList[iSMPanelButtons[Enum220.STANCEUP_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.UPDOWN_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.CLIMB_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.BURSTMODE_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.LOOK_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.TALK_BUTTON]].uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[Enum220.MUTE_BUTTON]].uiFlags &= ~BUTTON_DIRTY;

    ButtonList[giSMStealthButton].uiFlags &= ~BUTTON_DIRTY;

    // Make sure the options button is disabled
    ButtonList[iSMPanelButtons[Enum220.OPTIONS_BUTTON]].uiFlags &= ~BUTTON_ENABLED;

    // Make sure the mapscreen button is disabled
    ButtonList[iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]].uiFlags &= ~BUTTON_ENABLED;

    ButtonList[iSMPanelButtons[Enum220.STANCEUP_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.UPDOWN_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.CLIMB_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.STANCEDOWN_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.HANDCURSOR_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.BURSTMODE_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.LOOK_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.TALK_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[Enum220.MUTE_BUTTON]].uiFlags |= BUTTON_FORCE_UNDIRTY;

    ButtonList[giSMStealthButton].uiFlags |= BUTTON_FORCE_UNDIRTY;
  }
}

function IsMouseInRegion(pRegion: MOUSE_REGION): boolean {
  if ((gusMouseXPos >= pRegion.RegionTopLeftX) && (gusMouseXPos <= pRegion.RegionBottomRightX) && (gusMouseYPos >= pRegion.RegionTopLeftY) && (gusMouseYPos <= pRegion.RegionBottomRightY)) {
    return true;
  } else {
    return false;
  }
}

function EnableButtonsForInItemBox(fEnable: boolean): void {
  if (!fEnable) {
    DisableButton(iSMPanelButtons[Enum220.NEXTMERC_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.PREVMERC_BUTTON]);
    DisableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);
  } else {
    EnableButton(iSMPanelButtons[Enum220.NEXTMERC_BUTTON]);
    EnableButton(iSMPanelButtons[Enum220.PREVMERC_BUTTON]);

    if (!gfDisableTacticalPanelButtons) {
      EnableButton(iSMPanelButtons[Enum220.SM_MAP_SCREEN_BUTTON]);
    }
  }
}

function SMInvMoneyButtonCallback(pRegion: MOUSE_REGION, iReason: INT32): void {
  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  } else if (iReason == MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    // If the current merc is to far away, dont allow anything to be done
    if (gfSMDisableForItems)
      return;

    // if the player has an item in his hand,
    if (gpItemPointer != null) {
      // and the item is money
      if (Item[gpItemPointer.usItem].usItemClass == IC_MONEY) {
        let zText: string /* CHAR16[512] */;
        let zMoney: string /* CHAR16[64] */;

        // Make sure we go back to movement mode...
        guiPendingOverrideEvent = Enum207.A_CHANGE_TO_MOVE;
        HandleTacticalUI();

        zMoney = swprintf("%d", gpItemPointer.uiMoneyAmount);

        zMoney = InsertCommasForDollarFigure(zMoney);
        zMoney = InsertDollarSignInToString(zMoney);

        // ask the user if they are sure they want to deposit the money
        zText = swprintf(gzMoneyWithdrawMessageText[Enum374.CONFIRMATION_TO_DEPOSIT_MONEY_TO_ACCOUNT], zMoney);

        if (guiCurrentScreen == Enum26.SHOPKEEPER_SCREEN) {
          // if we are in the shop keeper interface, free the cursor
          if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
            FreeMouseCursor();
          }

          DoMessageBox(Enum24.MSG_BOX_BASIC_STYLE, zText, Enum26.SHOPKEEPER_SCREEN, MSG_BOX_FLAG_YESNO, ConfirmationToDepositMoneyToPlayersAccount, null);
        } else
          DoMessageBox(Enum24.MSG_BOX_BASIC_STYLE, zText, Enum26.GAME_SCREEN, MSG_BOX_FLAG_YESNO, ConfirmationToDepositMoneyToPlayersAccount, null);
      }
    }

    // else bring up the money item description box to remove money from the players account
    else {
      // set the flag indicating we are removing money from the players account
      gfAddingMoneyToMercFromPlayersAccount = true;

      // create the temp object from the players account balance
      //			if( LaptopSaveInfo.iCurrentBalance > MAX_MONEY_PER_SLOT )
      //				CreateMoney( MAX_MONEY_PER_SLOT, &gItemPointer );
      //			else
      CreateMoney(LaptopSaveInfo.iCurrentBalance, gItemPointer);

      InternalInitItemDescriptionBox(gItemPointer, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0, gpSMCurrentMerc);
    }
  }
}

function ConfirmationToDepositMoneyToPlayersAccount(ubExitValue: UINT8): void {
  if (ubExitValue == MSG_BOX_RETURN_YES) {
    // add the money to the players account
    AddTransactionToPlayersBook(Enum80.MERC_DEPOSITED_MONEY_TO_PLAYER_ACCOUNT, gpSMCurrentMerc.ubProfile, GetWorldTotalMin(), gpItemPointer.uiMoneyAmount);

    // dirty shopkeeper
    gubSkiDirtyLevel = Enum253.SKI_DIRTY_LEVEL2;

    EndItemPointer();
  }
}

export function ReEvaluateDisabledINVPanelButtons(): void {
  gfReEvaluateDisabledINVPanelButtons = true;
}

function CheckForReEvaluateDisabledINVPanelButtons(): void {
  // OK, if we currently have an item pointer up....
  if (gfReEvaluateDisabledINVPanelButtons) {
    if (gpItemPointer || gfInItemPickupMenu) {
      EnableSMPanelButtons(false, true);
    } else {
      EnableSMPanelButtons(true, true);
    }

    gfReEvaluateDisabledINVPanelButtons = false;
  }
}

function AbandonBoxingCallback(ubExitValue: UINT8): void {
  if (ubExitValue == MSG_BOX_RETURN_YES) {
    // ok, proceed!
    SetBoxingState(Enum247.NOT_BOXING);
    gfEnteringMapScreen = 1;
  }
  // otherwise do nothing
}

export function GoToMapScreenFromTactical(): void {
  if (gTacticalStatus.bBoxingState != Enum247.NOT_BOXING) {
    // pop up dialogue asking whether the player wants to abandon the fight
    DoMessageBox(Enum24.MSG_BOX_BASIC_STYLE, Message[Enum334.STR_ABANDON_FIGHT], Enum26.GAME_SCREEN, MSG_BOX_FLAG_YESNO, AbandonBoxingCallback, null);
    return;
  }
  // ok, proceed!
  gfEnteringMapScreen = 1;
}

export function HandleTacticalEffectsOfEquipmentChange(pSoldier: SOLDIERTYPE, uiInvPos: UINT32, usOldItem: UINT16, usNewItem: UINT16): void {
  // if in attached weapon mode and don't have weapon with GL attached in hand, reset weapon mode
  if (pSoldier.bWeaponMode == Enum265.WM_ATTACHED && FindAttachment(pSoldier.inv[Enum261.HANDPOS], Enum225.UNDER_GLAUNCHER) == NO_SLOT) {
    pSoldier.bWeaponMode = Enum265.WM_NORMAL;
    pSoldier.bDoBurst = 0;
  }

  // if he is loaded tactically
  if (pSoldier.bInSector) {
    // If this is our main hand
    if (uiInvPos == Enum261.HANDPOS || uiInvPos == Enum261.SECONDHANDPOS) {
      // check if we need to change animation!
      ReLoadSoldierAnimationDueToHandItemChange(pSoldier, usOldItem, usNewItem);
    }

    // if this is head gear
    if (uiInvPos == Enum261.HEAD1POS || uiInvPos == Enum261.HEAD2POS) {
      // Could be because of GOGGLES change...  Re-create light...
      DeleteSoldierLight(pSoldier);
      PositionSoldierLight(pSoldier);
    }
  } else {
    // as a minimum
    if ((Item[pSoldier.inv[Enum261.HANDPOS].usItem].usItemClass & IC_WEAPON) && Weapon[pSoldier.inv[Enum261.HANDPOS].usItem].ubShotsPerBurst == 0) {
      pSoldier.bDoBurst = 0;
      pSoldier.bWeaponMode = Enum265.WM_NORMAL;
    }
  }
}

}
